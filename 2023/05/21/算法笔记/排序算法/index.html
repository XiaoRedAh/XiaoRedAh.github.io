<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="萧">
    <link rel="canonical" href="http://example.com/2023/05/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            排序算法 |
        
        等想好起什么名字后再来改
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"0.5.2","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">
    
    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                等想好起什么名字后再来改
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        主页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        存档记录
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories"  >
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/link2">LINK2
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/link3">LINK3
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                主页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                存档记录
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/categories"  >
                             
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link2">LINK2</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link3">LINK3</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:2rem; font-weight: bold; margin: 10px 0;">排序算法</h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">萧</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-05-21 19:23:48</span>
        <span class="mobile">2023-05-21 19:23</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/">算法理论</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic%5C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png"
                     
                ></p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png"
                     
                ></p>
<p><strong>算法稳定性</strong></p>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1&#x3D;A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p>
<p><strong>算法稳定性干啥的</strong></p>
<p>算法稳定性的意义一般体现在按不同标准多次排序的场景</p>
<p>比如一个班的学生已经按照学号大小排好序了，现在要求按照年龄从小到大再排个序，如果年龄相同的，必须按照学号从小到大的顺序排列。如果选择的年龄排序方法是不稳定的，排序完了后年龄相同的一组学生学号就乱了；如果是稳定的排序算法，就只需要按照年龄排一遍就好了。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*直接插入排序：将有序数列外的元素插入有序数列，使有序数列一步步扩大，直至</span></span><br><span class="line"><span class="comment">	全体有序，即完成排序*/</span></span><br><span class="line">	<span class="comment">//初始时，默认第一个元素构成有序序列，因此第一个插入的元素是第二个元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = begin + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="type">int</span> temp = v[i];<span class="comment">//暂存待插入元素</span></span><br><span class="line">		<span class="type">int</span> j = i;<span class="comment">//j就是插入的位置，默认插在有序序列尾（待查元素本来的位置）</span></span><br><span class="line">		<span class="comment">//开始找位置</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt; begin &amp;&amp; v[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">			v[j] = v[j - <span class="number">1</span>];<span class="comment">//找位置的同时移位</span></span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		v[j] = temp;<span class="comment">//找到v[j-1]&lt;temp,插到它后面，即插入到v[j]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>一种优化的插入排序算法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*将距离为gap的整数倍的元素划分在一个子序列，对这些子序列进行直接插入排序</span></span><br><span class="line"><span class="comment">	使它们有序，然后缩小gap，重新划分，重复上述步骤，直至gap=1的划分全部排好序，</span></span><br><span class="line"><span class="comment">	集合全体就排号序了*/</span></span><br><span class="line">	<span class="comment">//其实就是比直接插入排序外层多了个用于更新gap的循环，在比较和挪位时衡量的长度变为gap</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> gap = (begin + end) / <span class="number">2</span>+<span class="number">1</span>; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//实际上就是比较和挪位时衡量的长度变为gap的直接插入排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = begin + gap; i &lt;= end; i++) &#123;</span><br><span class="line">			<span class="type">int</span> temp = v[i];</span><br><span class="line">			<span class="type">int</span> j = i;</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= begin+gap &amp;&amp; v[j - gap] &gt; temp) &#123;<span class="comment">//这里条件时&gt;=</span></span><br><span class="line">				v[j] = v[j - gap];</span><br><span class="line">				j=j-gap;</span><br><span class="line">			&#125;</span><br><span class="line">			v[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>注：以最小堆为例</p>
<p><strong>最初的思路</strong></p>
<p>最小堆的第一个元素是min，那就<code>deleteMin</code>得到min，将它放到另一个数组<code>temp</code>里，一直重复操作,temp里的元素就是有序的，最后将temp的元素<code>copy</code>回原数组</p>
<p><strong>优化一下——不额外开辟空间</strong></p>
<p>将堆第一个元素和堆最后一个元素交换，然后堆大小-1，调整堆序性，不断重复上述操作直至堆大小为0</p>
<p>这样操作可以避免额外开辟空间，用最小堆进行堆排序得到递减序列，用最大堆进行堆排序得到递增序列</p>
<p><strong>代码</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(T* arr,<span class="type">int</span> start, <span class="type">int</span> PosLastNode)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> PosFather = start;</span><br><span class="line">	<span class="type">int</span> PosChild = <span class="number">2</span> * start + <span class="number">1</span>;</span><br><span class="line">	T fatherKey = arr[PosFather];</span><br><span class="line">	<span class="keyword">while</span> (PosChild &lt;= PosLastNode) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PosChild&lt;PosLastNode &amp;&amp; arr[PosChild]&gt;arr[PosChild + <span class="number">1</span>])</span><br><span class="line">			PosChild++;</span><br><span class="line">		<span class="keyword">if</span> (arr[PosFather] &lt;= arr[PosChild])<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (arr[PosFather] &gt; arr[PosChild]) &#123;</span><br><span class="line">			arr[PosFather] = arr[PosChild];</span><br><span class="line">			arr[PosChild] = fatherKey;</span><br><span class="line">			PosFather = <span class="number">2</span> * PosFather + <span class="number">1</span>;</span><br><span class="line">			PosChild = <span class="number">2</span> * PosFather + <span class="number">1</span>;</span><br><span class="line">			fatherKey = arr[PosFather];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(T* arr, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先将传入的数组调整为堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = (length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		<span class="built_in">siftDown</span>(arr, i, length - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//将最小元素和堆最后一个元素交换位置，堆大小-1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">1</span>; i &gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">siftDown</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>divide-and-conquer分治思想(以二路归并为例)</strong></p>
<p>要排序全集S，就将全集S的前一半元素划分为S1，后一半元素划分为S2，排序S1，S2（这个排序也是遵从上面的策略），最后将有序的S1和S2合并成有序的全集S</p>
<p>从上面描述可知，归并排序就是将要排序的集合一步步划分为小集合，当这些小集合有序后，一步步返回合并为规模更大的有序集合，最终合并为有序的全集</p>
<p>因此可以用递归的方式实现递归算法：一步步将问题划分为更小的子问题，在返回（归）的过程中合并</p>
<p><strong>怎么合并两个有序集合</strong></p>
<blockquote>
<p>The basic merging algorithm takes two input arrays A and B, an output array C, and three counters, Actr, Bctr, and Cctr, which are initially set to the beginning of their respective arrays. The smaller of A[Actr] and B[Bctr] is copied to the next entry in C, and the appropriate counters are advanced. When either input list is exhausted, the remainder of the other list is copied to C</p>
</blockquote>
<p>写代码时，可以用一个暂存数组保存合并的结果，然后将暂存数组返回给原来的数组</p>
<p><strong>代码（二路归并）</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span>* temp, <span class="type">int</span> begin, <span class="type">int</span> mid ,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tempPos = begin;<span class="comment">//暂存数组的起始位置：S1的起始</span></span><br><span class="line">	<span class="type">int</span> leftStart = begin;<span class="comment">//S1的起始位置</span></span><br><span class="line">	<span class="type">int</span> leftEnd = mid;<span class="comment">//S1的终止位置</span></span><br><span class="line">	<span class="type">int</span> rightStart = mid + <span class="number">1</span>;<span class="comment">//S2的起始位置</span></span><br><span class="line">	<span class="type">int</span> rightEnd = end;<span class="comment">//S2的终止位置</span></span><br><span class="line">	<span class="type">int</span> N = end - begin + <span class="number">1</span>;<span class="comment">//记录S1和S2一共有多少元素</span></span><br><span class="line">	<span class="type">int</span> i = leftStart;<span class="comment">//指针i遍历S1</span></span><br><span class="line">	<span class="type">int</span> j = rightStart;<span class="comment">//指针j遍历S2</span></span><br><span class="line">	<span class="comment">//i，j分别遍历有序集合S1和S2，将小的放到暂存数组</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= leftEnd &amp;&amp; j &lt;= rightEnd) &#123;<span class="comment">//终止：S1或S2的所有元素都放到暂存数组了</span></span><br><span class="line">		<span class="keyword">if</span> (v[i] &lt; v[j])temp[tempPos++] = v[i++];</span><br><span class="line">		<span class="keyword">else</span> temp[tempPos++] = v[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= leftEnd) temp[tempPos++] = v[i++];<span class="comment">//将S1剩余的元素放入暂存数组</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt;= rightEnd) temp[tempPos++] = v[j++];<span class="comment">//将S2剩余的元素放入暂存数组</span></span><br><span class="line">	<span class="comment">//经过上述操作，暂存数组的begin到end这部分就是有序的，将它放回数组v</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = begin; k &lt; begin+N; k++)v[k] = temp[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span>* temp,<span class="type">int</span> begin,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end)<span class="keyword">return</span>;<span class="comment">//划分的集合里只有0或1个元素，不用排序直接返回</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = (begin + end) / <span class="number">2</span>;<span class="comment">//二路归并，将集合S划分为S1和S2</span></span><br><span class="line">		<span class="built_in">mergeSort</span>(v, temp, begin, mid);<span class="comment">//排序前一半元素S1</span></span><br><span class="line">		<span class="built_in">mergeSort</span>(v, temp, mid + <span class="number">1</span>, end);<span class="comment">//排序后一半元素S2</span></span><br><span class="line">		<span class="built_in">merge</span>(v, temp, begin, mid, end);<span class="comment">//将这两部分元素合并为一个有序序列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>经典冒泡</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*冒泡排序：要排序的数据有n个，则需要排n-1轮,每轮轮比完会将序列分</span></span><br><span class="line"><span class="comment">      为无序区和有序区两个区间，每轮排序都将最大元素交换到了最后（有序区的首位置），</span></span><br><span class="line"><span class="comment">	  每轮排序从begin开始相邻数据两两比较，若反序则交换，直到无序区比较完无序区</span></span><br><span class="line"><span class="comment">	  的最后两个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="type">bool</span> exchange;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end - begin; i++) &#123;<span class="comment">//排n-1轮</span></span><br><span class="line">		exchange = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = begin; j &lt; end - i; j++) &#123;<span class="comment">//每轮排序的逻辑</span></span><br><span class="line">			<span class="keyword">if</span> (v[j] &gt; v[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[j], v[j + <span class="number">1</span>]);</span><br><span class="line">				exchange = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (exchange == <span class="literal">false</span>)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优化冒泡</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="理论及实现"><a href="#理论及实现" class="headerlink" title="理论及实现"></a>理论及实现</h4><p>和归并排序一样，快排也采用 <strong>divide-and-conquer</strong> 思想，可以用递归算法实现</p>
<p><strong>对比归并排序的优势在于子问题的规模不要求一样大</strong></p>
<blockquote>
<p>Like mergesort, it recursively solves two subproblems and requires linear additional work (step 3), but, unlike mergesort, the subproblems are not guaranteed to be of equal size, which is potentially bad. The reason that quicksort is faster is that the partitioning step can actually be performed in place and very efficiently. This efficiency more than makes up for the lack of equal-sized recursive calls.</p>
</blockquote>
<p><strong>典型的快排包括以下四步</strong></p>
<p>从集合里拿出一个参照物（pivot），然后将剩余元素分成两部分（partition）：所有元素&lt;&#x3D;pivot的区域S1和所有元素均&gt;&#x3D;pivot的区域S2,最终返回S1+pivot+S2</p>
<blockquote>
<p>1、If the number of elements in S is 0 or 1, then return.<br>2、Pick any element v in S. This is called the pivot.<br>3、Partition S − {v} (the remaining elements in S) into two disjoint groups: S1 &#x3D; {x ∈S − {v}|x ≤ v}, and S2 &#x3D; {x ∈ S − {v}|x ≥ v}.<br>4、 Return {quicksort(S1) followed by v followed by quicksort(S2)}</p>
</blockquote>
<p>step2和step3实现的方法有很多种</p>
<p><strong>step2：如何选择参照物pivot</strong></p>
<p>不要选第一个元素作为pivot:<br>多数情况下，我们的输入是有序或部分有序的，这个时候挑选第一个元素作pivot，根据它分区会很不理想（因为两个分区元素数量差距会很悬殊，甚至有一个分区没有元素），这会导致浪费很多时间做无用的事</p>
<blockquote>
<p>if the input is presorted or in reverse order, then the pivot provides a poor partition, because either all the elements go into S1 or they go into S2.</p>
</blockquote>
<p>比较好的选取方式：随机选取&#x2F;三数取中</p>
<ul>
<li><p>随机选取法<br>rand()是C++中的随机数生成函数，返回一个0到RAND_MAX之间的伪随机整数。%（r - l + 1）将产生一个0到（r - l）之间的随机数，然后+l将偏移坐标以生成一个介于l和r之间的随机整数。</p>
<p>随机取数固然是一个很好的办法，但是假如运气不好，原先最左边的元素并不是最小或最大的一个元素，但是随机取到的元素却恰好是那个最小或最大的元素，反而导致了不平衡的划分。因此“三数取中法”似乎是更加稳健的选取方法</p>
  <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机选取pivot值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> random = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;<span class="comment">//生成一个介于l和r之间的随机整数</span></span><br><span class="line">	<span class="built_in">swap</span>(v[random], v[l]); <span class="comment">// 把pivot（随机选取）换到第一个元素位置</span></span><br><span class="line">	<span class="keyword">return</span> v[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>三数取中法<br>从集合中找三个元素（一般是begin，mid，end），取它们的中位数作pivot</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//三数取中法选取pivot参照</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> midPos = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//将三个数按升序排好序</span></span><br><span class="line">	<span class="keyword">if</span> (v[l] &gt; v[midPos])<span class="built_in">swap</span>(v[l], v[midPos]);</span><br><span class="line">	<span class="keyword">if</span> (v[l] &gt; v[r])<span class="built_in">swap</span>(v[l], v[r]);</span><br><span class="line">	<span class="keyword">if</span> (v[midPos] &gt; v[r])<span class="built_in">swap</span>(v[midPos], v[r]);</span><br><span class="line">	<span class="built_in">swap</span>(v[l], v[midPos]); <span class="comment">// 把pivot（中位数）换到第一个元素位置</span></span><br><span class="line">	<span class="keyword">return</span> v[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>step3：partiton</strong></p>
<p>经典划分：<br>选取基准值，获取划分位置。将原数组 a[l, r] 划分为两个子数组，在前一个数组中所有元素都小于等于pivot，后一个数组中所有元素都大于等于pivot。</p>
<p>有三种主流实现方法：左右指针法，挖坑法，前后指针法</p>
<p>这里采用左右指针法</p>
<blockquote>
<p>为什么先动右指针，再动左指针？<br>获取pivot的算法里，我的实现方法统一会把基准值pivot移到序列的第一位（以序列最左侧元素为基准值）。</p>
<p>规定在 i &#x3D;&#x3D; j 时退出循环。假设在某次交换之后，j 指向的是交换之后的一个大于基准值的元素。如果先动左指针 i 去寻找一个大于基准值的元素，还未找到就已经和右指针 j 相遇了。此时退出循环，交换基准值 pivot 到当前两个指针指向的位置。<br>但是!!!，此时 i 和 j 指向的是大于基准值的元素，进行交换基准值位置操作后，这个大于基准值的元素就被换到了序列的最左端，违反了partiton后的特性。</p>
<p>而如果先动右指针 j去寻找一个小于基准值的元素，找到就已经和左指针 i 相遇，此时退出循环，i 和 j 指向的一定是一个小于等于基准值的值。</p>
<p>究其原因，这其实是<strong>取最左边的元素作为基准值导致的</strong>。</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pivot = <span class="built_in">getPivot</span>(v, l, r);</span><br><span class="line">	<span class="type">int</span> i = l;</span><br><span class="line">	<span class="type">int</span> j = r;</span><br><span class="line">	<span class="comment">//左右指针法：先动右指针，再动左指针，左右指针相遇时停止</span></span><br><span class="line">	<span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; v[j] &gt;= pivot)j--;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; v[i] &lt;= pivot)i++;</span><br><span class="line">		<span class="built_in">swap</span>(v[i], v[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//停止时，指针所指元素指向的数&lt;pivot,因此可以直接把位于第一位置的pivot和它交换</span></span><br><span class="line">	<span class="built_in">swap</span>(v[i], v[l]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>快速排序完整代码实现</strong></p>
<p>采用三数取中选取pivot+左右指针法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三数取中法选取pivot参照</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> midPos = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//将三个数按升序排好序</span></span><br><span class="line">	<span class="keyword">if</span> (v[l] &gt; v[midPos])<span class="built_in">swap</span>(v[l], v[midPos]);</span><br><span class="line">	<span class="keyword">if</span> (v[l] &gt; v[r])<span class="built_in">swap</span>(v[l], v[r]);</span><br><span class="line">	<span class="keyword">if</span> (v[midPos] &gt; v[r])<span class="built_in">swap</span>(v[midPos], v[r]);</span><br><span class="line">	<span class="built_in">swap</span>(v[l], v[midPos]); <span class="comment">// 把pivot（中位数）换到第一个元素位置</span></span><br><span class="line">	<span class="keyword">return</span> v[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pivot = <span class="built_in">getPivot</span>(v, l, r);<span class="comment">//获得pivot，并将pivot移动到序列最左侧</span></span><br><span class="line">	<span class="type">int</span> i = l;</span><br><span class="line">	<span class="type">int</span> j = r;</span><br><span class="line">	<span class="comment">//左右指针法：先动右指针，再动左指针，左右指针相遇时停止</span></span><br><span class="line">	<span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; v[j] &gt;= pivot)j--;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; v[i] &lt;= pivot)i++;</span><br><span class="line">		<span class="built_in">swap</span>(v[i], v[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//停止时，指针所指元素指向的数&lt;pivot,因此可以直接把位于第一位置的pivot和它交换</span></span><br><span class="line">	<span class="built_in">swap</span>(v[i], v[l]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end)<span class="keyword">return</span>;<span class="comment">//若待排序的集合只有0或1个元素，直接返回</span></span><br><span class="line">	<span class="type">int</span> i = <span class="built_in">partition</span>(v, begin, end);</span><br><span class="line">	<span class="comment">//以pivot最终的位置i为参照，划分S1和S2，分别对它们再继续进行快排</span></span><br><span class="line">	<span class="built_in">quickSort</span>(v, begin, i - <span class="number">1</span>);<span class="comment">//对S1快排</span></span><br><span class="line">	<span class="built_in">quickSort</span>(v, i + <span class="number">1</span>, end);<span class="comment">//对S2快排</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="混合优化快排"><a href="#混合优化快排" class="headerlink" title="混合优化快排"></a>混合优化快排</h4><p>快排在数据量小（N&lt;&#x3D;20）的时候效率一般。我们可以在一开始数据量很大时用快排，当子序列的数据量缩小到一定值(5~15之间)，就转而用插入排序或其他在数据量小时效率更高的排序算法</p>
<blockquote>
<p>A common solution is not to use quicksort recursively for small arrays, but instead use a sorting algorithm that is efficient for small arrays, such as insertion sort. Using this strategy can actually save about 15 percent in the running time (over doing no cutoff at all). A good cutoff range is N &#x3D; 10, although any cutoff between 5 and 20 is likely to produce similar results. This also saves nasty degenerate cases, such as taking the median of three elements when there are only one or two.</p>
</blockquote>
<p>下面给出直接插入和快排混合算法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickInsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//数据量小的时候转而用直接插入排序</span></span><br><span class="line">	<span class="keyword">if</span> (end - begin &lt;= <span class="number">10</span>) <span class="built_in">insertSort</span>(v, begin, end);</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//数据量大的时候用快排</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用快速排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">int</span> i = <span class="built_in">partition</span>(v, begin, end);</span><br><span class="line">		<span class="comment">//以pivot最终的位置i为参照，划分S1和S2，分别对它们再继续进行快排</span></span><br><span class="line">		<span class="built_in">quickInsertSort</span>(v, begin, i - <span class="number">1</span>);<span class="comment">//对S1快排</span></span><br><span class="line">		<span class="built_in">quickInsertSort</span>(v, i + <span class="number">1</span>, end);<span class="comment">//对S2快排</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="双路快排"><a href="#双路快排" class="headerlink" title="双路快排"></a>双路快排</h4><h4 id="三路快排"><a href="#三路快排" class="headerlink" title="三路快排"></a>三路快排</h4><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*直接选择排序：在v[i]到v[end]中找到最小元素的位置（初始时i=begin），</span></span><br><span class="line"><span class="comment">	让它和第一个元素v[i]对调，然后i++，重复上述操作，当i=end-1时，全体排好序*/</span></span><br><span class="line">	<span class="comment">/*将数组看成左边的有序集合S1与右边的无序集合S2，将无序集合S2的最小元素v移动到</span></span><br><span class="line"><span class="comment">	S2首位置，那么v就自动加入到了S1，这时的S2就是原先的S2剔除掉首元素，重复上述</span></span><br><span class="line"><span class="comment">	操作，直到S1为全集，S2为空集，排序完成*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">		<span class="type">int</span> minPos = i;<span class="comment">//记录无序集合S2中最小元素的位置（默认为S2首元素）</span></span><br><span class="line">		<span class="comment">//开始找最小元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= end; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[j] &lt; v[minPos])minPos = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找到最小元素位置，如果最小元素不是S2的首元素，就移到首元素，否则不用动</span></span><br><span class="line">		<span class="keyword">if</span> (minPos != i)<span class="built_in">swap</span>(v[i], v[minPos]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Bucket-Sort桶排序"><a href="#Bucket-Sort桶排序" class="headerlink" title="Bucket Sort桶排序"></a>Bucket Sort桶排序</h2><h2 id="Counting-Sort基数排序"><a href="#Counting-Sort基数排序" class="headerlink" title="Counting Sort基数排序"></a>Counting Sort基数排序</h2><h2 id="Radix-Sort基数排序"><a href="#Radix-Sort基数排序" class="headerlink" title="Radix Sort基数排序"></a>Radix Sort基数排序</h2><h2 id="链表实现排序算法"><a href="#链表实现排序算法" class="headerlink" title="链表实现排序算法"></a>链表实现排序算法</h2><p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/TenosDoIt/p/3666585.html" >https://www.cnblogs.com/TenosDoIt/p/3666585.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h1>
            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：排序算法</li>
        <li>Post author：萧</li>
        <li>Create time：2023-05-21 19:23:48</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/05/21/算法笔记/排序算法/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/05/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">数据库设计</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/05/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">二分查找</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div style="font-size: 1.3rem;margin-top: 0; margin-bottom: 0.8rem; transition-duration: 0.1s;"><i class="fa-solid fa-list"></i> <strong>Contents</strong></div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%8E%92%E5%BA%8F"><span class="nav-text">内排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E8%A7%88"><span class="nav-text">总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-text">性能对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">希尔排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-text">理论及实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E4%BC%98%E5%8C%96%E5%BF%AB%E6%8E%92"><span class="nav-text">混合优化快排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E8%B7%AF%E5%BF%AB%E6%8E%92"><span class="nav-text">双路快排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92"><span class="nav-text">三路快排</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">直接选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bucket-Sort%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">Bucket Sort桶排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Counting-Sort%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">Counting Sort基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Radix-Sort%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">Radix Sort基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">链表实现排序算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%96%E6%8E%92%E5%BA%8F"><span class="nav-text">外排序</span></a></li></ol>
    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">萧. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v0.5.2</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/8/17 11:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        

        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fa-solid fa-magnifying-glass-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fa-solid fa-magnifying-glass-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fa-solid fa-left-right"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fa-solid fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fa-solid fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fa-solid fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fa-solid fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>




    
<script src="/js/runtime.js"></script>

    
<script src="/js/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
