<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="萧">
    <link rel="canonical" href="http://example.com/2023/06/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            事务管理 |
        
        等想好起什么名字后再来改
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"0.5.2","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">
    
    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                等想好起什么名字后再来改
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        主页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        存档记录
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories"  >
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/link2">LINK2
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/link3">LINK3
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                主页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                存档记录
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/categories"  >
                             
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link2">LINK2</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link3">LINK3</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:2rem; font-weight: bold; margin: 10px 0;">事务管理</h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">萧</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-06-04 12:46:48</span>
        <span class="mobile">2023-06-04 12:46</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/">数据库理论</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>事务定义</strong>：事务是由一系列访问和更新操作组成的程序执行单元。这些操作要么都做，要么都不做，是一个不可分割的整体</p>
<p><strong>SQL中的事务</strong><br>事务以<code>Begin transaction</code>语句开始(SQL Server是Start Transaction)，以<code>Commit</code> 或<code>Rollback</code>语句结束</p>
<ul>
<li><code>Commit</code>：提交事务。此时事务正常结束，事务所做的修改操作都必须<strong>永久地写入数据库</strong></li>
<li><code>Rollback</code>：回滚事务。此时事务非正常结束，事务所做的**修改操作都必须撤销(Undo，数据改回旧值)**。数据库回退到事务开始前的状态，就好像事务从来没有发生过一样。</li>
<li>如果事务还没有来得及执行Commit，就因某种原因（故障）而终止了，那么系统就要自动地回滚这个事务</li>
</ul>
<p><em>注意：commit&#x3D;写入日志!&#x3D;写入磁盘。永久写入数据库指的是写入磁盘，而这个操作其实是操作系统调度的（将非热点数据写入磁盘）</em></p>
<p><strong>事务四大特性（ACID）</strong></p>
<ul>
<li>**原子性(Atomicity)**：事务的所有操作(特指修改操作)要么全部做，要么都不做。通过<code>恢复机制</code>实现</li>
<li>**一致性(Consistency)**：独立执行一个事务（无其它事务同时并发执行）的结果必须保证数据一致性。即事务开始前，数据满足一致性要求；事务结束后，数据虽然变化了，但仍然满足一致性的要求。由<code>程序员负责</code>，借助<code>完整性机制</code>实现。<ul>
<li>例如在银行系统中，转帐事务的一致性要求是前后两个帐户的金额总和不变。假如一个事务为帐户A减去100，为帐户B加上50，那么这个事务就违反了一致性。</li>
</ul>
</li>
<li>**隔离性(Isolation)**：任何一对事务T1、T2，在T1看来，T2要么在T1开始之前已经结束，要么在T1结束以后再开始执行 (T2对数据库的修改，T1要么全部看到，要么全部看不到)。通过<code>并发控制机制</code>实现。</li>
<li>**持久性(Durability)**：一个事务成功完成后，它对数据库的改变必须是永久的，即使系统出现故障。通过<code>恢复机制</code>实现。</li>
</ul>
<p><strong>事务的读和写</strong></p>
<p>数据库的存储以块为单位，假设数据项X位于磁盘中的数据块B，事务T1，T2都要用到X，读写流程如下：</p>
<ul>
<li>input(B)将X从磁盘的B数据块输入到全局缓冲区，T1，T2分别read(X)将全局缓冲区的X读入到自己事务的私有缓冲区。</li>
<li>T1用write(x)将事务T1的私有缓冲区中的X写回全局缓冲区，全局缓冲区通过output(B)将这个X输出到磁盘中的数据块B位置</li>
</ul>
<p><img src="https://image.itbaima.net/images/253/image-20230619214480381.png" alt="pic/事务读和写"></p>
<p>综上，事务的读写分别用read(X)，write(X)表示，是在事务自己的主存缓冲区上操作。write(X)并不一定立即更新磁盘上的数据</p>
<p><strong>事务状态</strong></p>
<ul>
<li><strong>活动状态</strong>：事务开始后进入<ul>
<li>事务处于本状态时，顺序执行事务中的每条语句</li>
</ul>
</li>
<li><strong>部分提交状态</strong>：执行完事务的全部语句后进入<ul>
<li>事务处于本状态时，将已做的每个修改操作永久化，即把对应的日志记录写入到磁盘上。这样即使修改操作后来丢失了（比如磁盘损坏），也能根据这些日志记录（永久化信息）来恢复它</li>
</ul>
</li>
<li><strong>提交状态</strong>：提交全部修改操作后进入<ul>
<li>事务处于本状态时，<strong>事务结束</strong></li>
</ul>
</li>
<li><strong>失败状态</strong><ul>
<li>在活动状态中，执行某条语句失败时进入</li>
<li>在部分提交状态中，（对某个修改操作）永久化失败时进入</li>
<li>事务处于本状态时，不断回滚已经发生的修改操作</li>
</ul>
</li>
<li><strong>中止状态</strong>：回滚事务，数据库恢复到事务执行前的状态后进入<ul>
<li>事务处于本状态时，<strong>事务结束</strong></li>
</ul>
</li>
</ul>
<p><img src="https://image.itbaima.net/images/253/image-20230619219555881.png" alt="pic/事务状态"></p>
<p>执行一个事务可能经过的状态：</p>
<ul>
<li>活动状态 → 部分提交状态 → 提交状态</li>
<li>活动状态 → 失败状态 → 中止状态</li>
<li>活动状态 → 部分提交状态 → 失败状态 → 中止状态</li>
</ul>
<h1 id="详解事务隔离性"><a href="#详解事务隔离性" class="headerlink" title="详解事务隔离性"></a>详解事务隔离性</h1><h2 id="事务调度"><a href="#事务调度" class="headerlink" title="事务调度"></a>事务调度</h2><p><strong>事务调度</strong>：指系统执行事务中指令的时间顺序，必须保证：</p>
<ul>
<li>包含了所有事务的操作指令</li>
<li>同一个事务中指令的相对顺序必须保持不变</li>
</ul>
<p><strong>串行调度</strong>：执行完一个事务才开始执行下一个事务。从时间顺序上看，同一事务的指令紧挨在一起</p>
<p><strong>并发调度</strong>：未执行完一个事务时，可转去执行另一个事务。从时间顺序上看，不同事务的指令彼此交叉（多种执行顺序）</p>
<p><strong>并发调度优点</strong></p>
<ul>
<li>提高系统吞吐量：给定时间内，执行的事务数增加</li>
<li>提高资源利用率：CPU与磁盘的空闲时间减少</li>
<li>减少等待时间<ul>
<li>减少不可预测的延迟：比如串行调度，短事务可能要等待前面的长事务完成，可能导致难以预测的延迟。</li>
<li>减少<code>平均响应时间</code>(事务从提交到完成所需的平均时间)</li>
</ul>
</li>
</ul>
<p><em>数据库使用并发执行的动机本质上与操作系统使用<code>多道程序</code>的动机是一样的</em></p>
<p><strong>并发调度需要考虑是否违反隔离性</strong></p>
<ul>
<li>串行调度多个事务时，不会破坏数据一致性。</li>
<li>并行调度多个事务时，可能会、也可能不会破坏数据一致性。这往往取决于并发调度是否违反隔离性</li>
</ul>
<h2 id="并发调度带来的问题"><a href="#并发调度带来的问题" class="headerlink" title="并发调度带来的问题"></a>并发调度带来的问题</h2><p><strong>并发调度的问题</strong>:<br>一旦并发调度无法保证隔离性（<strong>因</strong>），就可能破坏数据一致性（<strong>果</strong>）。即使单个事务的执行可以保证一致性，但当多个这样的事务在并发调度时，也可能破坏数据一致性。</p>
<p><strong>解决方法</strong>: 使并发调度<em>可串行化</em><br>具体地说，对于一个并发调度</p>
<ul>
<li>如果本身就是可串行化的，那么它就是一个正确的调度（隔离性得到保证，从而保证数据一致性），可以直接执行。</li>
<li>如果本身是不可串行化的，那就对其进行并发控制<ul>
<li>若并发控制改变了执行次序，将其改造成可串行化，那么这个并发调度就变成了一个正确的调度。</li>
<li>若并发控制不能改变执行次序，无法将其改造成可串行化，那么这个并发调度是有问题的。</li>
</ul>
</li>
</ul>
<p><strong>错误的并发调度（没保证隔离性）带来的三个问题</strong><br><em>本质都是看到中间态</em></p>
<ul>
<li>**丢失修改(写覆盖)**：并发调度两个事务T1、T2。T1与T2从数据库中读入同一数据后分别修改。假设T1先提交，而T2后提交，则T2提交的修改覆盖了T1提交的修改，导致T1的修改丢失。</li>
<li><strong>不可重复读</strong>：事务T1读取某些数据（记录）后，事务T2对这些数据（记录）做了某种修改操作。当T1再次读取该数据（记录）时，得到的是与前一次不同的值。<em>分为三种情况—在事务T1两次读取之间：</em><ul>
<li>另一事务T2更新了记录。则当T1第二次读取时，得到与前一次不同的记录值</li>
<li>另一事务T2删除了部分记录。则当T1第二次读取时，发现其中的某些记录神秘地消失了（<strong>幻影&#x2F;幻读现象</strong>）</li>
<li>另一事务T2插入了一些记录。则当T1第二次按相同条件读取时，发现地神秘地多了一些记录（<strong>幻影&#x2F;幻读现象</strong>）</li>
</ul>
</li>
<li><strong>读“脏”数据</strong>：事务T1修改某一数据，并写入数据库，但尚未结束(提交)，事务T2读取同一数据，得到的是T1修改后的新值。事务T1由于某种原因被撤消，则数据库中的数据恢复为修改前的旧值。事务T2读到的数据就与数据库最终的数据不一致，是不正确的数据，又称为“脏”数据 —— 其它事务修改后但又被撤销（回滚）的数据。</li>
</ul>
<p><em>广义的“脏”数据：凡是另一事务修改过但是还没有提交的数据，对本事务来说都是“脏”的。在严格要求正确性的场合，读“脏”数据是不允许的</em></p>
<p><em>写覆盖举例：有数据项A&#x3D;0，事务T1对A加200，事务T2对A加100。如果是串行调度，那没有问题，T1和T2谁先调度，最后的A都是300。但如果是错误的并发调度，T1的写回操作先执行的话，会被后执行的T2的写操作覆盖，导致最后的A是100；反之，最后的A是200。</em></p>
<h2 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h2><p>事务的串行调度显然不会破坏数据一致性</p>
<p><strong>可串行化</strong>：事务的并发调度效果上等价于某个串行调度。</p>
<p><em>注意：不考虑一个事务对某一数据项可执行的不同类型的操作。<strong>只考虑read和write。</strong>（从调度角度看，事务唯一重要的操作是read和write）</em></p>
<p>这里只讨论<strong>冲突可串行化</strong></p>
<p><em>注意：冲突可串行化是可串行化的充分条件，不是必要条件</em></p>
<p><strong>判断事务T1的指令I和事务T2的指令J是否冲突</strong><br><em>冲突指的是I，J执行的先后顺序对结果有影响</em></p>
<ul>
<li>I，J操作的数据项不同，一定不冲突</li>
<li>I，J操作的数据项相同<ul>
<li>都是read指令，则不冲突</li>
<li>至少一个是write指令，则冲突（两个都是wirte看似不冲突，但会影响后来read的数据，所以冲突）</li>
</ul>
</li>
</ul>
<p><strong>冲突等价</strong>：调度S经过一系列非冲突指令交换，变成调度S’，则称S与S’冲突等价。</p>
<p><strong>冲突可串行化</strong>：如果调度S与一个串行调度冲突等价，则S是冲突可串行化的。</p>
<hr>
<p><strong>例1</strong><br>并发调度S（包含T1，T2）</p>
<table>
<thead>
<tr>
<th>T1</th>
<th>T2</th>
</tr>
</thead>
<tbody><tr>
<td>read(A)</td>
<td></td>
</tr>
<tr>
<td>write(A)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>read(A)</td>
</tr>
<tr>
<td></td>
<td>write(A)</td>
</tr>
<tr>
<td>read(B)</td>
<td></td>
</tr>
<tr>
<td>write(B)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>read(B)</td>
</tr>
<tr>
<td></td>
<td>write(B)</td>
</tr>
</tbody></table>
<p>冲突等价于以下串行调度，因此是S是冲突可串行化的</p>
<table>
<thead>
<tr>
<th>T1</th>
<th>T2</th>
</tr>
</thead>
<tbody><tr>
<td>read(A)</td>
<td></td>
</tr>
<tr>
<td>write(A)</td>
<td></td>
</tr>
<tr>
<td>read(B)</td>
<td></td>
</tr>
<tr>
<td>write(B)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>read(A)</td>
</tr>
<tr>
<td></td>
<td>write(A)</td>
</tr>
<tr>
<td></td>
<td>read(B)</td>
</tr>
<tr>
<td></td>
<td>write(B)</td>
</tr>
</tbody></table>
<p><strong>例二</strong><br>以下并发调度S不等价于任何一个串行调度，是不可串行化的</p>
<table>
<thead>
<tr>
<th>T1</th>
<th>T2</th>
</tr>
</thead>
<tbody><tr>
<td>read(A)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>write(A)</td>
</tr>
<tr>
<td>write(A)</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="并发控制机制"><a href="#并发控制机制" class="headerlink" title="并发控制机制"></a>并发控制机制</h2><p>并发控制机制的任务：</p>
<ul>
<li>正确地并发调度事务（可串行化）</li>
<li>保证事务的隔离性</li>
<li>保证数据一致性</li>
</ul>
<h3 id="基于锁的协议"><a href="#基于锁的协议" class="headerlink" title="基于锁的协议"></a>基于锁的协议</h3><p><strong>封锁</strong>：事务T在对某个数据对象（关系、元组等）进行操作之前，先向系统发出请求，对其加锁。事务T对某个数据对象加锁后，其它事务就不能对这个数据对象进行某些相应操作，直到事务T释放它的锁为止。</p>
<p><strong>封锁协议</strong>：事务对数据对象加锁时，还需要遵守某些规则，包括：何时加锁，何时释放。称这些规则为封锁协议</p>
<p><strong>锁的相容函数</strong>：事务Tj在数据项Q上拥有B类型锁，此时事务Ti请求对Q加A类型锁。如果可以立即获得Q上的A类型锁，就称A，B类型锁是相容的。</p>
<p>比如说，对数据项Q上A类型锁，只有等待Q上所有与A不相容类型的锁全部释放，才能对Q上A类型锁。</p>
<p><strong>锁的强度</strong>：指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然</p>
<h4 id="X锁与S锁"><a href="#X锁与S锁" class="headerlink" title="X锁与S锁"></a>X锁与S锁</h4><p><strong>封锁基本类型</strong></p>
<ul>
<li><strong>S锁（读锁&#x2F;共享锁）share</strong><br>事务T 对数据对象A进行读取操作前，给A加上S锁。加上S锁后，其它事务能再对A加S锁，但不能加X锁，直到T释放A上的S锁为止</li>
<li><strong>X锁（写锁&#x2F;排它锁）exclusive</strong><br>事务T 对数据对象A进行修改操作前，给A加上X锁。加上X锁后，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的X锁为止</li>
</ul>
<p>lock-S(Q)，lock-X(Q)分别对数据项Q上S锁和X锁，unlock(Q)释放数据项Q上的锁。</p>
<p><strong>S锁与X锁的相容矩阵</strong><br>这两种锁之间，只有S锁和S锁是相容的。<br>这保证了可以让多个事务读取一个数据项，但同时只能有一个事务进行写操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>X</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
<h4 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h4><p><strong>规定</strong>：<em>若要修改数据R</em>，事务T必须先对其<em>加X锁</em>(数据R最早的读写操作前)，<em>X锁直到事务结束(commit或rollback后)才释放</em></p>
<p>一级封锁协议可<strong>解决丢失修改</strong>的问题：<br>没有事务能够修改其它事务正在修改，还未提交的数据</p>
<h4 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h4><p><strong>规定</strong>：一级封锁协议 + <em>若要读取数据R</em>，事务T必须先对其<em>加S锁</em>(数据R最早的读操作前)，在读完后，可以在<em>任意时候释放S锁</em></p>
<p>二级封锁协议在一级协议的基础上，可<strong>解决读脏数据</strong>的问题：<br>没有事务能够读取其它事务正在修改，还未提交的数据（这样的数据是有X锁的，而X锁和S锁是不相容的，无法申请到S锁进行读取）</p>
<h4 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><p><strong>规定</strong>：一级封锁协议 + <em>若要读取数据R</em>，事务T必须先对其<em>加S锁</em>(数据R最早的读操作前)，直到<em>事务结束后才释放S锁</em></p>
<p>三级封锁协议在二级协议的基础上，可<strong>解决不可重复读</strong>的问题<br>没有事务能够修改其它事务正在读取的数据（这个数据持有事务A的S锁，另一事务B的写操作申请的X锁需要等待这个S锁的释放，而它是事务A结束后才释放的，因此….）</p>
<hr>
<p><strong>小结</strong></p>
<table>
<thead>
<tr>
<th>封锁协议</th>
<th>何时加X锁</th>
<th>何时释放X锁</th>
<th>何时加S锁</th>
<th>何时释放S锁</th>
<th>丢失修改</th>
<th>读脏数据</th>
<th>不可重复读</th>
</tr>
</thead>
<tbody><tr>
<td>一级封锁协议</td>
<td>首次<strong>读写</strong>操作开始</td>
<td>事务结束</td>
<td>×</td>
<td>×</td>
<td>N</td>
<td></td>
<td></td>
</tr>
<tr>
<td>二级封锁协议</td>
<td>首次<strong>读写</strong>操作开始</td>
<td>事务结束</td>
<td>读操作开始</td>
<td>读操作结束</td>
<td>N</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>三级封锁协议</td>
<td>首次<strong>读写</strong>操作开始</td>
<td>事务结束</td>
<td>读操作开始</td>
<td>事务结束</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<hr>
<h4 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h4><blockquote>
<p>二阶段封锁协议偏理论，判断精准，但实现难度大。真正的设计（DBMS）一般都采用一、二、三级封锁协议(虽然比较粗放，但已经足够)</p>
</blockquote>
<p><strong>规定</strong>：在对<em>任何数据进行读写之前，事务首先要获得对该数据进行封锁</em>，释放封锁后不能再读、写该数据。在释放第一个封锁之后，事务不再获得任何其它封锁，即事务分为两个阶段</p>
<ul>
<li>生长阶段：事务可以获得锁，但不能释放锁	   </li>
<li>收缩阶段：事务可以释放锁，但不能获得新锁</li>
</ul>
<p>首次释放掉一个封锁后，即由生长阶段转入收缩阶段</p>
<p><em>可以理解为所有lock是一个串行调度S1，所有unlock是一个串行调度S2。S2只能在S1之后调度，lock和unlock调度顺序不允许出现交叉</em></p>
<p><strong>定理</strong>：若所有事务均遵从两段锁协议，则对这些事务的并行调度都是可串行化的</p>
<p>反过来，在一个可串行化调度中，不一定所有事务都遵从两段锁协议<br>因此，所有事务都遵从两段锁协议，是可串行化调度的充分不必要条件</p>
<h4 id="多粒度与意向锁"><a href="#多粒度与意向锁" class="headerlink" title="多粒度与意向锁"></a>多粒度与意向锁</h4><p>前面的并发控制机制，都是将单独的数据项作为同步执行的单元<br>有些时候，需要把多个数据项聚为一组，将它们作为一个同步单元</p>
<p>比如：事务Ti需要访问整个数据库。如果以单个数据项为同步单元，就需要对每个数据项封锁，非常耗时。如果能只发出单个加锁请求，就可以封锁整个数据库，那么效率会大大提高。</p>
<p><strong>多级粒度机制</strong>：通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大粒度数据项中来实现。</p>
<p><strong>粒度设计要把握好度</strong>：粒度大，开销减小，但并发性也会减小；粒度小，并发性会更好，但开销增大</p>
<p><strong>多粒度的层次结构可以用“树”表示</strong></p>
<p>树的每个结点可以单独加锁（显示的）。事务Ti对某结点显示地加锁后，该结点地全部后代会<strong>隐式地</strong>加上同样类型的锁。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.iHvMy9kWPv6bkH8JqGe3OAHaEZ?pid=ImgDet&rs=1"
                     
                ></p>
<p><strong>隐式加锁带来的问题</strong></p>
<p>比如ra被隐式加锁，事务Ti此时对ra发出加锁请求。由于ra没有显示加锁，系统应该如何判断Ti是否可以封锁ra呢？</p>
<p>解决方法：从树根遍历到ra，如果路径上某结点的锁与要加的锁类型不相容，则Ti必须推迟。</p>
<p><strong>如何判断根节点是否可以加锁</strong></p>
<ul>
<li>遍历搜索整颗树：这个方法破坏了多粒度封锁机制的初衷</li>
<li>给一个结点显式加锁之前，给该结点的<em>全部祖先结点都加上意向锁</em>。这样就不必搜索整颗树了。</li>
</ul>
<p><strong>意向锁</strong></p>
<ul>
<li>目的：提高对某个数据对象加锁时系统的检查效率</li>
<li>对任一结点加基本锁，必须先对它的上层结点加意向锁</li>
<li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁</li>
</ul>
<p><strong>常用意向锁</strong></p>
<ul>
<li><strong>IS锁</strong>：如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。</li>
<li><strong>IX锁</strong>：如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁（也可以加S锁）。</li>
<li><strong>SIX锁</strong>：如果一个事务对一个数据对象加SIX锁，表示对这个事务对它加了S锁，再加IX锁，即SIX &#x3D; S + IX。【<strong>以该结点为根的子树显式地加S锁，树的更低层次显式地加IX锁</strong>】<ul>
<li>比如：对某个表加SIX锁，表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。</li>
</ul>
</li>
</ul>
<p><strong>相容矩阵</strong>：写累了，上网看就行。</p>
<h4 id="多粒度封锁协议"><a href="#多粒度封锁协议" class="headerlink" title="多粒度封锁协议"></a>多粒度封锁协议</h4><p>详细规则在意向锁的概念里有提及</p>
<ul>
<li>申请封锁时应该按自上而下的次序进行</li>
<li>释放封锁时则应该按自下而上的次序进行</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁更详细的分析在操作系统笔记中，这里不做深入。</p>
<p><strong>死锁</strong>：如果有两个事务同时要对两个不同的数据加锁就有可能发生相互等待的问题，从而形成死锁（资源等待出现环路）。</p>
<p>死锁是采取封锁带来的必然产物（有出现的隐患），一旦出现死锁，系统必须<strong>回滚两个事务中的一个</strong>。</p>
<p><strong>死锁预防</strong></p>
<ul>
<li><strong>顺序封锁法</strong>：为所有数据对象定义一个顺序级别，所有事务都必须按照这个顺序进行封锁</li>
<li><strong>抢占与事务回滚</strong>：若事务T2申请的锁被T1所持有，则可以通过回滚T1，抢占原来T1持有的锁并授予T2</li>
</ul>
<p><strong>死锁检测与恢复</strong>：允许发生死锁，检测死锁后，选择<strong>代价最小的事务回滚</strong></p>
<ul>
<li><strong>超时法</strong>：若事务的等待时间超过规定，就认为发生了死锁。有可能误判</li>
<li><strong>等待图法</strong>：事务等待图是一个有向图 G ＝ ( T, U )：T为代表事务的结点集合；U为边的集合，若事务T1等待T2，则在U中增加一条从T1到T2的有向边。周期性检测事务等待图G，若存在回路，则表示系统中发生了死锁</li>
</ul>
<h3 id="基于时间戳的协议"><a href="#基于时间戳的协议" class="headerlink" title="基于时间戳的协议"></a>基于时间戳的协议</h3><p>课堂上没讲，先略。</p>
<h3 id="基于有效性检查的协议"><a href="#基于有效性检查的协议" class="headerlink" title="基于有效性检查的协议"></a>基于有效性检查的协议</h3><p>课堂上没讲，先略</p>
<h3 id="多版本机制"><a href="#多版本机制" class="headerlink" title="多版本机制"></a>多版本机制</h3><p>课堂上没讲，先略</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>SQL标准规定的隔离性级别如下（一致性强度逐级增强）</p>
<ul>
<li><strong>未提交读</strong>（Read uncommitted）：允许读取未提交的数据。并发操作会导致脏读</li>
<li><strong>已提交读</strong>（read committed）：只允许读取已提交的数据，但不要求可重复读。解决脏读问题，并发操作会导致不可重复读</li>
<li><strong>可重复读</strong>（repeatable read）：只允许读取已提交的数据，而且一个事务两次读取同一数据项之间，其他事务不得更新该数据。不要求与其他事务可串行化。解决不可重复读问题，并发操作会导致幻读。</li>
<li><strong>可串行化</strong>（Serializable）：保证可串行化调度。</li>
</ul>
<p>以上四个隔离级别都<strong>不允许脏写</strong>：若一个数据项已经被另一个尚未提交或中止的事务写入，则不允许对该数据项执行写操作。</p>
<h1 id="恢复系统"><a href="#恢复系统" class="headerlink" title="恢复系统"></a>恢复系统</h1><h2 id="故障分类"><a href="#故障分类" class="headerlink" title="故障分类"></a>故障分类</h2><p><strong>事务故障</strong>：因某种错误，事务无法继续执行而失败。</p>
<ul>
<li><strong>原因</strong><ul>
<li>事务内部执行语句产生<strong>逻辑错误</strong>。例如：除零、运算溢出，余额不足…</li>
<li>事务外部条件造成的<strong>系统错误</strong>。例如：死锁造成事务无法正常执行（但未来可以重新执行）。</li>
</ul>
</li>
<li><strong>后果</strong>：发生故障的那一个事务异常结束，其他事务仍正常运行</li>
<li><strong>恢复</strong>：UNDO 故障事务 — 找到故障事务的全部修改并撤消(改回旧值)，纠正“修改已写入磁盘”的错误。</li>
</ul>
<p>**系统崩溃 (system crash)**：因某种错误，造成DBMS停止运行</p>
<ul>
<li><strong>原因</strong><ul>
<li>硬件错误。例如CPU或内存故障等</li>
<li>软件错误。例如OS或者DBMS的漏洞引发异常。</li>
<li>其它，例如突然停电等。</li>
</ul>
</li>
<li><strong>后果</strong>：易失性存储器（缓冲区）内容丢失，非易失性存储器（磁盘）完好无损，事务异常停止，系统需要重启。</li>
<li><strong>恢复</strong><ul>
<li>UNDO 未提交事务 — 找到这些事务的全部修改并撤消(改回旧值) ，纠正“修改已写入磁盘”的错误。</li>
<li>REDO 已提交事务 — 找到这些事务的全部修改并重做 (改成新值) ，纠正“修改未写入磁盘”的错误</li>
</ul>
</li>
</ul>
<p>**磁盘故障 (disk crash)**：因某种故障，磁盘上的数据部分或完全丢失。</p>
<ul>
<li><strong>原因</strong>：一般是相关的人为破坏或者硬件故障，例如：错误的格式化、磁盘坏道、磁头损坏、机房失火等。</li>
<li><strong>后果</strong>：磁盘上的数据丢失。</li>
<li><strong>恢复</strong>：根据其它地点（磁盘、磁带）上的数据备份，重建数据库。</li>
</ul>
<h2 id="恢复技术"><a href="#恢复技术" class="headerlink" title="恢复技术"></a>恢复技术</h2><blockquote>
<p><strong>什么叫做修改了数据库？</strong><br>一个事务执行了对磁盘缓冲区（公共缓冲区）或磁盘的更新时，这个事务修改了数据库；<br>而事务对自己的私有缓冲区部分进行更新，不算作修改数据库。</p>
<p>如果事务直到提交时都没有修改数据库，就称它采用了<strong>延迟修改</strong>技术。如果数据库修改在事务仍然活跃时发生，就称它采用了<strong>立即修改</strong>技术</p>
</blockquote>
<p>恢复的基本原理：<strong>冗余</strong><br>任何数据被破坏或发生错误后，都可以通过存储在其它地点的冗余数据重建该数据。</p>
<p>恢复技术的关键<br>一、如何<strong>建立冗余数据</strong></p>
<ul>
<li>数据转储</li>
<li>登记日志文件</li>
</ul>
<p>二、恢复策略（如何<strong>根据冗余数据，重建正确的数据</strong>）</p>
<ul>
<li>事务故障的恢复</li>
<li>系统故障的恢复</li>
<li>磁盘故障的恢复</li>
</ul>
<h3 id="建立冗余数据"><a href="#建立冗余数据" class="headerlink" title="建立冗余数据"></a>建立冗余数据</h3><h4 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h4><p>操作系统对这方面介绍更详细。</p>
<p><strong>数据存储</strong>：由DBA定期将数据库进行复制，得到后备副本并保存在另外的磁盘或磁带上的过程。</p>
<p><strong>静态转储 vs 动态转储</strong></p>
<ul>
<li><strong>静态转储</strong>：在转储期间，系统中不能有事务运行。<ul>
<li>优点：实现简单，得到的数据库副本有一致性。</li>
<li>缺点：转储时，数据库不可用。</li>
</ul>
</li>
<li><strong>动态转储</strong>：在转储期间，允许事务存取或修改数据。<ul>
<li>优点：转储时，数据库是可用的。</li>
<li>缺点：实现复杂，不能保证数据库副本有一致性。</li>
</ul>
</li>
</ul>
<p><strong>海量(完全)转储 vs 增量转储</strong></p>
<ul>
<li><strong>海量转储</strong>：转储整个数据库。</li>
<li><strong>增量转储</strong>：转储（自上次转储以来）发生变化的那部分数据。</li>
</ul>
<h4 id="登记日志"><a href="#登记日志" class="headerlink" title="登记日志"></a>登记日志</h4><p>日志是日志记录的序列，记录数据库中所有的更新活动。</p>
<p><strong>两种类型的日志文件</strong></p>
<ul>
<li>以<strong>记录为操作对象</strong>的日志文件（只讨论这种）</li>
<li>以数据块为操作对象的日志文件</li>
</ul>
<p><strong>登记到日志文件的内容</strong></p>
<ul>
<li>登记事务开始(Begin Transaction)的日志记录</li>
<li>登记事务结束(Commit 或 Rollback)的日志记录</li>
<li>登记事务中修改操作对象的日志记录(每次修改对应一条记录)</li>
</ul>
<p><strong>一条更新日志记录（描述一次数据库写操作）具有以下字段</strong></p>
<ul>
<li><strong>事务标识</strong>（哪个事务? ）&#x3D;事务的编号</li>
<li><strong>操作类型</strong>（哪种操作?）&#x3D;事务开始／事务结束／添加／删除／更新</li>
<li><strong>数据项标识</strong>（哪个操作对象?）&#x3D;数据项在磁盘的位置（块标识及块内偏移量）</li>
<li><strong>旧值</strong></li>
<li><strong>新值</strong></li>
</ul>
<p>&lt;Ti，Xi，V1，V2&gt;：事务Ti对数据项Xi执行一次写操作，旧值是V1，新值是V2</p>
<p><strong>登记日志文件需遵循的原则</strong></p>
<ul>
<li>日志的登记次序严格<strong>遵循事务调度的时间次序</strong>（哪个指令先执行，哪个指令的日志先登记）</li>
<li>对一个修改操作，必须<strong>先写日志，后修改</strong>（内存中）</li>
<li>事务提交，先把所有日志文件写到磁盘，再把修改写回磁盘</li>
</ul>
<p>例如：<br>指令次序：事务开始→事务修改→事务结束<br>日志次序：开始记录→修改记录→结束记录</p>
<p><strong>日志文件的作用</strong></p>
<ul>
<li>事务故障、系统故障的恢复，必须使用日志文件：UNDO和REDO都要从日志文件中去查找修改记录</li>
<li>磁盘故障的恢复，使用转储产生的副本＋日志文件<ul>
<li>在动态转储方式中，必须建立日志文件：后备副本和日志文件综合起来，才能重建一致性的数据库。</li>
<li>在静态转储方式中，也应该建立日志文件：后备副本只能把数据库恢复到转储结束时的状态，为恢复到故障前的最近状态，需要根据转储以后的日志文件REDO已提交事务，UNDO未提交事务。</li>
</ul>
</li>
</ul>
<h3 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h3><p>UNDO操作需要反向扫描日志文件（从后往前回滚）<br>REDO操作需要正向扫描日志文件</p>
<h4 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h4><p>由系统自动完成，对用户透明（不介入）<br>恢复过程（UNDO该事务）：</p>
<ol>
<li><strong>反向扫描</strong>日志文件，查找该事务的全部修改记录。</li>
<li>对每个修改记录撤消：将记录中“旧值”写入memory。</li>
<li><strong>扫描到该事务的开始记录为止</strong>，事务故障恢复即告完成。</li>
</ol>
<h4 id="系统故障的恢复"><a href="#系统故障的恢复" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h4><p>由DBMS在重新启动后自动完成，不需要用户的干预。<br>恢复步骤：（没提交的UNDO，已提交的REDO）</p>
<ol>
<li><strong>正向扫描</strong>日志文件，找到故障发生前已提交（有开始和Commit记录）的全部事务，把其事务标识放入重做队列；找到故障发生前尚未提交（有开始无Commit记录）的全部事务，将其事务标识记入撤消队列。</li>
<li><strong>UNDO撤消队列</strong>中的所有事务——<strong>反向扫描</strong>日志文件，对属于这些事务的修改记录，撤消：写入“旧值”到memory。</li>
<li><strong>REDO重做队列</strong>中的所有事务——<strong>正向扫描</strong>日志文件，对属于这些事务的修改记录，重做：写入“新值”到memory。</li>
</ol>
<h4 id="介质-磁盘-故障的恢复"><a href="#介质-磁盘-故障的恢复" class="headerlink" title="介质(磁盘)故障的恢复"></a>介质(磁盘)故障的恢复</h4><p>磁盘故障的恢复一般由DBA来完成。<br>恢复步骤：</p>
<ol>
<li>装入最近一次转储的数据库副本，并使数据库恢复到最近一次转储时的状态。（对于动态转储得到的副本，还需同时装入转储时的日志文件副本，通过REDO+UNDO恢复到一致性状态）</li>
<li>装入转储后到故障发生时的日志文件副本，REDO那些已提交事务。恢复到故障发生时的数据库状态。</li>
</ol>
<h2 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h2><p><strong>使用日志进行恢复时的性能问题</strong></p>
<blockquote>
<p>问题1: 随着操作越来越多，日志文件持续增长，变得很大<br>问题2: 有必要完整地扫描全部日志吗?<br>两点导致性能低下<br>1、日志文件很长，完整扫描很耗时<br>2、对于大部分早已结束的事务，它们的修改已经写入磁盘&#x2F;撤销了。REDO、UNDO它们实际上就是再写入或者撤销一遍修改，虽然不会造成错误，但是浪费了时间。</p>
</blockquote>
<p><strong>解决方案</strong><br>把日志分为相对小得多的若干段，在进行恢复时，<strong>把扫描的范围尽量限制在最后的一两段内</strong>。检查点可以作为这种段间的分隔。</p>
<p><strong>检查点</strong>：日志文件中的一类记录，内容包括：</p>
<ul>
<li>写入该检查点时，系统中所有活动（还没结束的）事务列表。</li>
<li>这些活动事务在日志文件中的开始记录地址。</li>
</ul>
<p><strong>重新开始文件</strong><br>内容：记录各个检查点在日志文件中的地址。<br>作用：快速在日志文件中定位检查点，特别是最后一个检查点。</p>
<p><strong>引入检查点后，日志文件的登记</strong><br>一、周期性建立检查点的流程</p>
<ol>
<li>将缓冲中的所有日志记录，修改写入到磁盘(先写日志，后写数据)</li>
<li>然后在日志文件中写入一个检查点记录；</li>
<li>把这个检查点记录在日志文件中的地址写入重新开始文件 (检查点生效)</li>
</ol>
<p>二、此外，在事务开始、结束、修改数据时，仍和原来一样进行登记日志记录的操作。</p>
<p><strong>如果事务T在建立检查点cp前已提交，那么REDO该事务是否必要?</strong>　<br>提交意味着T的全部修改已经写入数据库——要么写入了磁盘，要么仍在缓冲中。<br>T提交后建立检查点cp，则缓冲中所有修改包括T的那些，全部写入磁盘。<br>所以cp一旦成功建立，意味着T的全部修改已写入磁盘，也意味着T无必要REDO (REDO是为了防止已提交事务修改未写入磁盘的错误)</p>
<p><strong>根据最后建立的检查点cp，可以把事务分为</strong></p>
<ul>
<li>A类: cp前已提交的事务 (Start&lt;Commit&lt;cp)</li>
<li>B类: cp时正活动的事务 (Start&lt;cp)</li>
<li>C类: cp后才开始的事务 (cp&lt;Start)</li>
</ul>
<p>Start:  事务开始记录；Commit:  事务提交记录</p>
<p><strong>发生故障时，A类事务不用处理，要处理的是BC类事务</strong></p>
<p>B类事务实际上就是检查点的活动事务列表。<br>C类事务特征是事务开始记录在 cp 后。<br>BC类事务有已提交的 (需要REDO) ，也有未提交的 (需要UNDO)。如果BC类事务已提交，那么在日志中有commit记录，并且这个记录一定在cp后面。</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：事务管理</li>
        <li>Post author：萧</li>
        <li>Create time：2023-06-04 12:46:48</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/06/04/数据库笔记/事务管理/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/">#数据库理论</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/06/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/DBS%E6%A6%82%E8%BF%B0/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">DBS概述</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/05/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">数据库设计</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div style="font-size: 1.3rem;margin-top: 0; margin-bottom: 0.8rem; transition-duration: 0.1s;"><i class="fa-solid fa-list"></i> <strong>Contents</strong></div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%A6%E8%A7%A3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-text">详解事务隔离性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-text">事务调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">并发调度带来的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-text">可串行化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">并发控制机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-text">基于锁的协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#X%E9%94%81%E4%B8%8ES%E9%94%81"><span class="nav-text">X锁与S锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-text">一级封锁协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-text">二级封锁协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-text">三级封锁协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-text">两阶段封锁协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%B2%92%E5%BA%A6%E4%B8%8E%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-text">多粒度与意向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%B2%92%E5%BA%A6%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-text">多粒度封锁协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-text">基于时间戳的协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9C%89%E6%95%88%E6%80%A7%E6%A3%80%E6%9F%A5%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-text">基于有效性检查的协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="nav-text">多版本机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">事务隔离级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F"><span class="nav-text">恢复系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E5%88%86%E7%B1%BB"><span class="nav-text">故障分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="nav-text">恢复技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%86%97%E4%BD%99%E6%95%B0%E6%8D%AE"><span class="nav-text">建立冗余数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8"><span class="nav-text">数据转储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BB%E8%AE%B0%E6%97%A5%E5%BF%97"><span class="nav-text">登记日志</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="nav-text">恢复策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-text">事务故障的恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-text">系统故障的恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E8%B4%A8-%E7%A3%81%E7%9B%98-%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-text">介质(磁盘)故障的恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="nav-text">检查点</span></a></li></ol></li></ol>
    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">萧. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v0.5.2</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/8/17 11:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        

        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fa-solid fa-magnifying-glass-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fa-solid fa-magnifying-glass-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fa-solid fa-left-right"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fa-solid fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fa-solid fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fa-solid fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fa-solid fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>




    
<script src="/js/runtime.js"></script>

    
<script src="/js/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
