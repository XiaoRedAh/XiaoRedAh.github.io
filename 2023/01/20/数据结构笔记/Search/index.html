<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="萧">
    <link rel="canonical" href="http://example.com/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Search/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            搜索 |
        
        等想好起什么名字后再来改
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"0.5.2","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">
    
    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                等想好起什么名字后再来改
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        主页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        存档记录
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories"  >
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/link2">LINK2
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/link3">LINK3
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                主页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                存档记录
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/categories"  >
                             
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link2">LINK2</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link3">LINK3</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:2rem; font-weight: bold; margin: 10px 0;">搜索</h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">萧</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-01-20 13:28:48</span>
        <span class="mobile">2023-01-20 13:28</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h2 id="顺序搜索小优化——设置监视哨"><a href="#顺序搜索小优化——设置监视哨" class="headerlink" title="顺序搜索小优化——设置监视哨"></a>顺序搜索小优化——设置监视哨</h2><p><em>将要搜索的值赋值给数组最后一个元素的下一个位置，这样就不用每次比较都判断是否越界</em></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SeqSearchWatch</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//将数组最后一个元素的下一个元素赋值为要搜索的值，这样就不用每次循环都判断是否越界（肯定会找到，从下标位置就能看出有没有越界）</span></span><br><span class="line">	element[currentSize].key = x;</span><br><span class="line">	<span class="keyword">while</span> (element[i].key != x)i++;</span><br><span class="line">	<span class="keyword">if</span> (i == currentSize)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="基于有序数据的二分查找"><a href="#基于有序数据的二分查找" class="headerlink" title="基于有序数据的二分查找"></a>基于有序数据的二分查找</h2><p>结点结构体定义：data+key，按key查找</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataNode</span> &#123;</span><br><span class="line">	T key;</span><br><span class="line">	E data;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div>

<p><em>写代码时注意low，high，mid的边界情况和查找结束&#x2F;失败时的情况就行</em>  </p>
<p><em>下面的代码返回的是物理位置：数组下标+1</em>  </p>
<p>迭代实现</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(T x，DataNoed&lt;T,E&gt;* element,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> low= <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> high = size;</span><br><span class="line">	<span class="keyword">while</span> (low&lt;=high) &#123;</span><br><span class="line">		mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (element[mid].key == x)<span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (element[mid].key &gt; x)high = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (element[mid].key &lt; x)low = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>递归实现</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearchR</span><span class="params">(T x,DataNode&lt;T,E&gt; *element,<span class="type">int</span> low,<span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &gt; high)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; element[mid].key)mid=<span class="built_in">BinarySearchR</span>(x,element, mid + <span class="number">1</span>, high);</span><br><span class="line">	<span class="keyword">if</span> (x &lt; element[mid].key)mid=<span class="built_in">BinarySearchR</span>(x,element, low, mid - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> mid;<span class="comment">//实际位置=mid+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="BST二叉搜索树"><a href="#BST二叉搜索树" class="headerlink" title="BST二叉搜索树"></a>BST二叉搜索树</h2><ul>
<li>思想：用动态搜索结构实现二分查找</li>
<li>左子树的值&gt;根节点值&gt;右子树的值</li>
<li>中序遍历下输出递增序列</li>
<li>搜索：类似于二分查找，很方便</li>
<li>插入：<ul>
<li>操作：从根节点开始不断比较直至找到可以插入的空位置（插入后成为叶子结点）</li>
<li>同样的值，不同的插入顺序，会构建出不同的BST（这就需要AVL进行优化结构）</li>
</ul>
</li>
<li>删除：分为三种情况（设删除结点为<code>del</code>）<ul>
<li><code>del</code>没有孩子:直接删</li>
<li><code>del</code>只有一个孩子：孩子接替<code>del</code>的位置(孩子的子树一并带过来)，然后删<code>del</code></li>
<li><code>del</code>有两个孩子：用中序遍历下<code>del</code>的前驱或<code>del</code>的后继结点接替<code>del</code>，并将删除任务转变为删值&#x3D;接替结点的值（最后还是会变成前两种情况）</li>
</ul>
</li>
<li>自己写删除代码时的问题：<ul>
<li>删除操作在遍历前&#x2F;后时，代码里的else写在哪</li>
<li>删除任务转变后，往哪去删除？<ol>
<li>用前驱接替：<code>Remove(temp-&gt;data,root-&gt;left)</code></li>
<li>用后继接替：<code>Remove(temp-&gt;data,root-&gt;right)</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">	T data;</span><br><span class="line">	BSTNode* left;</span><br><span class="line">	BSTNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BST</span>() &#123;root = <span class="literal">nullptr</span>;&#125;;</span><br><span class="line">	~<span class="built_in">BST</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T <span class="title">getRootData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root-&gt;data; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T d)</span> </span>&#123;<span class="built_in">insert</span>(d, root);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MidPrint</span><span class="params">()</span> </span>&#123;<span class="built_in">MidPrint</span>(root);&#125;</span><br><span class="line">	<span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(T d)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">search</span>(d, root); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Remove</span><span class="params">(T d)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Remove</span>(d, root); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	BSTNode&lt;T&gt;* root;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T d,BSTNode&lt;T&gt; *&amp;root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			BSTNode&lt;T&gt;* insert = <span class="keyword">new</span> BSTNode&lt;T&gt;;</span><br><span class="line">			insert-&gt;data = d;</span><br><span class="line">			insert-&gt;left = insert-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">			root = insert;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (d &lt; root-&gt;data)<span class="built_in">insert</span>(d, root-&gt;left);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">insert</span>(d, root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MidPrint</span><span class="params">(BSTNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">MidPrint</span>(root-&gt;left);</span><br><span class="line">		cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">MidPrint</span>(root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(T d, BSTNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span>(d==root-&gt;data)<span class="keyword">return</span> root;</span><br><span class="line">		<span class="keyword">if</span> (d &lt; root-&gt;data)<span class="built_in">search</span>(d, root-&gt;left);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">search</span>(d, root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Remove</span><span class="params">(T d, BSTNode&lt;T&gt;*&amp; root)</span> </span>&#123;</span><br><span class="line">		BSTNode&lt;T&gt;* temp;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//如果将删除结点的操作放到遍历前，第一个判断递归Remove就要用else if</span></span><br><span class="line">		<span class="comment">//因为删除结点操作中有一种情况没有return，若没有else，会继续执行下面语句导致错误</span></span><br><span class="line">		<span class="keyword">if</span> (d &lt; root-&gt;data)<span class="built_in">Remove</span>(d, root-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (d &gt; root-&gt;data)<span class="built_in">Remove</span>(d, root-&gt;right);</span><br><span class="line">		<span class="comment">//有else才能说明d==root-&gt;data,找到了被删结点</span></span><br><span class="line">		<span class="comment">//若没有else，则无论有没有找到，只要前面Remove调用完，就会走到下面的删除，导致乱删</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right != <span class="literal">nullptr</span>) &#123;<span class="comment">//被删结点有两个孩子</span></span><br><span class="line">			<span class="comment">//temp指针去找在中序遍历下被删结点root的后继结点</span></span><br><span class="line">			<span class="comment">//中序遍历下结点的后继是该结点右子树中左支走到底的那个结点</span></span><br><span class="line">			temp = root-&gt;right;</span><br><span class="line">			<span class="comment">//将被删结点的值替换为后继结点的值</span></span><br><span class="line">			<span class="keyword">while</span> (temp-&gt;left != <span class="literal">nullptr</span>)temp = temp-&gt;left;</span><br><span class="line">			root-&gt;data = temp-&gt;data;</span><br><span class="line">			<span class="comment">//删除任务转变成了删结点值=temp-&gt;data的结点</span></span><br><span class="line">			<span class="comment">//注意第二个参数，不能直接赋值为temp</span></span><br><span class="line">			<span class="built_in">Remove</span>(temp-&gt;data, root-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//被删结点有1个或0个孩子（看似分两种情况，实际上代码可以一次解决）</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			temp = root;</span><br><span class="line">			<span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				root = root-&gt;right; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> root = root-&gt;left;</span><br><span class="line">			<span class="keyword">delete</span> temp;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="AVL平衡树（优化BST）"><a href="#AVL平衡树（优化BST）" class="headerlink" title="AVL平衡树（优化BST）"></a>AVL平衡树（优化BST）</h2><ul>
<li>提出：有时构建出的BST极度不平衡，甚至退化为线性结构，搜索效率降低</li>
<li>前置规定：<ul>
<li>平衡因子bf&#x3D;右子树高度-左子树高度</li>
<li>什么时候平衡：$\vert bf\vert$&lt;&#x3D;1</li>
<li>最小失衡子树：从新插入的结点开始向上查找，以第一个bf失衡的结点为根的子树</li>
</ul>
</li>
<li>四种失衡类型及对应旋转方法（设最小失衡子树根节点root）</li>
</ul>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/suimeng/p/4560056.html" >详细图解点这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  </p>
<p><strong>思路：判断类型后先明确旋转完后以谁为新的根节点。右子树高，则向左旋转，左子树高，则向右旋转，旋转完还要更新bf值</strong>  </p>
<blockquote>
<p><em>书面描述旋转（结合上面的图解）</em><br>左旋转：root的右孩子变成其右孩子的左孩子，然后root变成其右孩子的左孩子<br>右旋转：root的左孩子变成其左孩子的右孩子，然后root变成其左孩子的右孩子</p>
</blockquote>
<ol>
<li>单旋转（根与较高子树根结点bf同号）<br>   <em>旋转后，根节点变为root的l或r（看类型）</em><ul>
<li>LL型(右旋)：root左子树高，root的左孩子也是左边高</li>
<li>RR型（左旋）：root右子树高，root的右孩子也是右边高</li>
</ul>
</li>
<li>双旋转（根与较高子树根节点bf异号）<br>   <em>从下往上调整，旋转后根节点变为root的l的r或root的r的l（看类型）</em><ul>
<li>LR型（先左后右旋）：root的左子树高，root的左孩子是右边高</li>
<li>RL型（先右后左选）：root的右子树高，root的右孩子是左边高</li>
</ul>
</li>
</ol>
<ul>
<li>插入</li>
</ul>
<p>找到插入位置并插入$\Longrightarrow$回溯更新沿途节点bf，找最小失衡子树 $\Longrightarrow$ 找到后判断失衡类型并旋转(只需调整一次，不用再回溯了)$\Longrightarrow$将调整的那部分接回AVL树  </p>
<ul>
<li>实现细节<br><strong>1. 沿途结点用栈维护；找插入位置，更新父节点bf，判断失衡类型都要用到双指针</strong><br><strong>2. 更新后的父节点bf</strong><ol>
<li>bf&#x3D;0,已经平衡，结束回溯，插入成功</li>
<li>$\vert bf\vert$&#x3D;1,父节点平衡，仍要回溯，更新父节点的父节点bf并判断</li>
<li>$\vert bf\vert$&gt;1，父节点失衡，判断失衡类型并旋转</li>
</ol>
</li>
</ul>
<p><strong>代码实现</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">	T data;</span><br><span class="line">	<span class="type">int</span> bf;<span class="comment">//平衡因子=右子树高度-左子树高度</span></span><br><span class="line">	AVLNode* left;</span><br><span class="line">	AVLNode* right;</span><br><span class="line">	<span class="built_in">AVLNode</span>(T d) :<span class="built_in">data</span>(d), <span class="built_in">bf</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVL</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AVL</span>() &#123; root = <span class="literal">nullptr</span>; &#125;;</span><br><span class="line">	~<span class="built_in">AVL</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T <span class="title">getRootData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root-&gt;data; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MidPrint</span><span class="params">()</span> </span>&#123; <span class="built_in">MidPrint</span>(root); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(T d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">insert</span>(root, d);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	AVLNode&lt;T&gt;* root;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MidPrint</span><span class="params">(AVLNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">MidPrint</span>(root-&gt;left);</span><br><span class="line">		cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">MidPrint</span>(root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(AVLNode&lt;T&gt;*&amp; parent)</span> </span>&#123;</span><br><span class="line">		AVLNode&lt;T&gt;* newchild = parent;</span><br><span class="line">		parent = parent-&gt;right;</span><br><span class="line">		newchild-&gt;right = parent-&gt;left;</span><br><span class="line">		parent-&gt;left = newchild;</span><br><span class="line">		parent-&gt;bf = newchild-&gt;bf = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(AVLNode&lt;T&gt;*&amp; parent)</span> </span>&#123;</span><br><span class="line">		AVLNode&lt;T&gt;* newchild = parent;</span><br><span class="line">		parent = parent-&gt;left;</span><br><span class="line">		newchild-&gt;left = parent-&gt;right;</span><br><span class="line">		parent-&gt;right = newchild;</span><br><span class="line">		parent-&gt;bf = newchild-&gt;bf = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RotateLR</span><span class="params">(AVLNode&lt;T&gt;*&amp; parent)</span> </span>&#123;</span><br><span class="line">		AVLNode&lt;T&gt;* ancestor = parent;</span><br><span class="line">		parent = parent-&gt;left;</span><br><span class="line">		AVLNode&lt;T&gt;* father = parent;</span><br><span class="line">		parent = parent-&gt;right;</span><br><span class="line">		<span class="comment">//先左旋</span></span><br><span class="line">		father-&gt;right = parent-&gt;left;</span><br><span class="line">		parent-&gt;left = father;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;bf &lt;= <span class="number">0</span>)father-&gt;bf = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> father-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">//后右旋</span></span><br><span class="line">		ancestor-&gt;left = parent-&gt;right;</span><br><span class="line">		parent-&gt;right = ancestor;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;bf == <span class="number">-1</span>)ancestor-&gt;bf = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> ancestor-&gt;bf = <span class="number">0</span>;</span><br><span class="line">		parent-&gt;bf = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RotateRL</span><span class="params">(AVLNode&lt;T&gt;*&amp; parent)</span> </span>&#123;</span><br><span class="line">		AVLNode&lt;T&gt;* ancestor = parent;</span><br><span class="line">		parent = parent-&gt;right;</span><br><span class="line">		AVLNode&lt;T&gt;* father = parent;</span><br><span class="line">		parent = parent-&gt;left;</span><br><span class="line">		<span class="comment">//先右旋</span></span><br><span class="line">		father-&gt;left = parent-&gt;right;</span><br><span class="line">		parent-&gt;right = father;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;bf &gt;= <span class="number">0</span>)father-&gt;bf = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> father-&gt;bf = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//后左旋</span></span><br><span class="line">		ancestor-&gt;right = parent-&gt;left;</span><br><span class="line">		parent-&gt;left = ancestor;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;bf == <span class="number">1</span>)ancestor-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> ancestor-&gt;bf = <span class="number">0</span>;</span><br><span class="line">		parent-&gt;bf = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(AVLNode&lt;T&gt;*&amp; root, T d)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//空树直接插入并返回true</span></span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			root = <span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;T&gt;(d);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;AVLNode&lt;T&gt;*&gt; stack;<span class="comment">//存放经过的结点,为了插入后的回溯</span></span><br><span class="line">		AVLNode&lt;T&gt;* temp = root;<span class="comment">//用做遍历指针</span></span><br><span class="line">		AVLNode&lt;T&gt;* parent = <span class="literal">nullptr</span>;<span class="comment">//双指针--父指针</span></span><br><span class="line">		<span class="comment">//找插入位置</span></span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (d == temp-&gt;data)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有重复值则不插入</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				parent = temp;</span><br><span class="line">				stack.<span class="built_in">push_back</span>(parent);</span><br><span class="line">				<span class="keyword">if</span> (d &lt; temp-&gt;data)temp = temp-&gt;left;</span><br><span class="line">				<span class="keyword">else</span> temp = temp-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找到插入位置后，创建新节点并插入</span></span><br><span class="line">		AVLNode&lt;T&gt;* newNode = <span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;T&gt;(d);</span><br><span class="line">		<span class="keyword">if</span> (d &lt; parent-&gt;data)parent-&gt;left = newNode;</span><br><span class="line">		<span class="keyword">else</span> parent-&gt;right = newNode;</span><br><span class="line">		<span class="comment">//回溯：更新父节点bf，并判断是否要调整（只需调整一次）</span></span><br><span class="line">		AVLNode&lt;T&gt;* child = newNode;</span><br><span class="line">		<span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="comment">//获得当前结点的父节点</span></span><br><span class="line">			parent = stack.<span class="built_in">back</span>();</span><br><span class="line">			stack.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="comment">//更新父节点bf</span></span><br><span class="line">			<span class="keyword">if</span> (parent-&gt;left == child)parent-&gt;bf--;</span><br><span class="line">			<span class="keyword">else</span> parent-&gt;bf++;</span><br><span class="line">			<span class="comment">//判断是否要调整</span></span><br><span class="line">			<span class="keyword">if</span> (parent-&gt;bf == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (parent-&gt;bf == <span class="number">1</span>||parent-&gt;bf==<span class="number">-1</span>)child = parent;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> childBf = (parent-&gt;bf &lt; <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//判断子节点bf值的同时也判断了父与子的bf是否同号</span></span><br><span class="line">				<span class="keyword">if</span> (child-&gt;bf == childBf) &#123;<span class="comment">//父与子的bf同号，单旋转</span></span><br><span class="line">					<span class="keyword">if</span> (child-&gt;bf == <span class="number">-1</span>)<span class="built_in">RotateR</span>(parent);</span><br><span class="line">					<span class="keyword">else</span> <span class="built_in">RotateL</span>(parent);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;<span class="comment">//父与子的bf异号，双旋转</span></span><br><span class="line">					<span class="keyword">if</span> (child-&gt;bf == <span class="number">-1</span>)<span class="built_in">RotateRL</span>(parent);</span><br><span class="line">					<span class="keyword">else</span> <span class="built_in">RotateLR</span>(parent);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//调整一次就行</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//end while</span></span><br><span class="line">		<span class="comment">//将调整的那一部分接回AVL里</span></span><br><span class="line">		<span class="keyword">if</span> (stack.<span class="built_in">empty</span>())root = parent;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			AVLNode&lt;T&gt;* n = stack.<span class="built_in">back</span>();</span><br><span class="line">			<span class="keyword">if</span> (parent-&gt;data &lt; n-&gt;data)n-&gt;left = parent;</span><br><span class="line">			<span class="keyword">else</span> n-&gt;right = parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h2 id="DisJoint-Set-union-find-set并查集"><a href="#DisJoint-Set-union-find-set并查集" class="headerlink" title="DisJoint Set(union-find set并查集)"></a>DisJoint Set(union-find set并查集)</h2><h3 id="前置-1"><a href="#前置-1" class="headerlink" title="前置"></a>前置</h3><p><strong>干啥用的</strong></p>
<p>（动态）等价问题；解决一些图论问题（[例子：kruskal算法](Graph.md#kruskal算法）<br>主要就是两个操作：<code>Find</code>和<code>Union</code></p>
<blockquote>
<p>An efficient data structure to solve the equivalence problem.These operations（Find&#x2F;Union） are important in many graph theory problems and also in compilers which process equivalence (or type) declarations. </p>
</blockquote>
<p><strong>啥是不相交集合（Disjoint Set）</strong></p>
<blockquote>
<p>Each set has a different<br>element, so that Si ∩ Sj &#x3D; ∅; this makes the sets disjoint.</p>
</blockquote>
<p><strong>等价关系和等价类</strong>：离散数学的知识</p>
<p><strong>存储结构</strong></p>
<p>同一个等价类放在一个树里（不是二叉树），这样的话，树根就可以代表这一个等价类（或者说set）。这么多树的集合就构成了一个森林</p>
<blockquote>
<p>One idea might be to use a tree to represent each set, since each element in a tree has the same root. Thus, the root can be used to name the set. We will represent each set by a tree. (Recall that a collection of trees is known as a forest.) Initially, each set contains one element.</p>
</blockquote>
<p><em>用数组s存储上述的森林，</em><br>$s[i]&#x3D;\begin{cases}<br>元素i的parent &amp; i不是root\<br>按union方法而异（&lt;0，只有根节点时是-1） &amp; i是root\<br>\end{cases}$</p>
<blockquote>
<p>The name of a set is given by the node at the root. Since only the name of the parent is required, we can assume that this tree is stored implicitly in an array: Each entry s[i] in the array represents the parent<br>of element i. If i is a root, t</p>
</blockquote>
<h3 id="两个基本操作：Find和Union"><a href="#两个基本操作：Find和Union" class="headerlink" title="两个基本操作：Find和Union"></a>两个基本操作：Find和Union</h3><p><strong>不需要比较</strong></p>
<blockquote>
<p>We do not perform any operations comparing the relative values of elements<br>but merely require knowledge of their location. </p>
</blockquote>
<p><strong>Find</strong></p>
<p>理论</p>
<p>find返回的是元素所在集合（等价类）的名字</p>
<blockquote>
<p>A find(x) on element x is performed by returning the root of the tree containing x.finds on two elements return the same answer if and only if they are in the same set. </p>
</blockquote>
<p><strong>Union</strong></p>
<p>理论</p>
<blockquote>
<p>If we want to add the relation a ∼ b, then we first see if a and b are already related. This is done by performing finds on both a and b and checking whether they are in the same equivalence class. If they are not, then we apply union.This operation merges the two equivalence classes containing a and b into a new equivalence class.</p>
</blockquote>
<p>一个不太好的Union方法：容易搞出退化的树<br>将一个树的root直接置为另一个树的子女</p>
<blockquote>
<p>Making the second tree a subtree of the first</p>
</blockquote>
<h3 id="优化并查集性能"><a href="#优化并查集性能" class="headerlink" title="优化并查集性能"></a>优化并查集性能</h3><p>并查集主要的操作就是<code>find</code>和<code>union</code>，从上述讨论中发现，简单的<code>find</code>和<code>union</code>性能并不理想，需要去优化</p>
<p><strong>优化Union：为了避免产生退化的树</strong></p>
<ul>
<li><p><strong>union-by-size</strong><br>$s[i]&#x3D;\begin{cases}<br>  元素i的parent &amp; i不是root\<br>  树的结点总数（&lt;0，只有根节点时是-1） &amp; i是root\<br>  \end{cases}$ </p>
<p>  理论<br>  并操作时，结点少的树成为结点多的树的孩子</p>
<blockquote>
<p>A simple improvement is always to make the smaller tree a subtree of the larger,breaking ties by any method</p>
</blockquote>
<p>  性能分析</p>
<blockquote>
<p>If unions are done by size, the depth of any node is never more than logN.This implies that the running time for a find operation is O(logN),and a sequence of M operations takes O(M logN). </p>
</blockquote>
</li>
<li><p><strong>union-by-height</strong><br>$s[i]&#x3D;\begin{cases}<br>  元素i的parent &amp; i不是root\<br>  树的高度（按结点定义高度）（&lt;0，初值为-1） &amp; i是root\<br>  \end{cases}$  </p>
<p>  理论<br>  高度小的树成为高度大的树的孩子，实际上和union-by-size思路是一样的</p>
<blockquote>
<p>We keep track of the height, instead of the size,of each tree and perform unions by making the shallow tree a subtree of the deeper tree.</p>
</blockquote>
<p>  性能<br>和union-by-size一样</p>
</li>
</ul>
<p><strong>优化Find：Path Compression</strong><br>当<code>union</code>优化到极致后，我们发现worst-case trees的产生无法避免，那就只能在<code>find</code>操作上优化</p>
<blockquote>
<p>This is based on the observation that any method to perform the unions will yield the same worst-case trees, since it must break ties arbitrarily. Therefore, the only way to speed the algorithm up, without reworking the data structure entirely, is to do something clever on the find operation</p>
</blockquote>
<p>路径压缩什么情况下使用<br>路径压缩是在<code>Find</code>操作里进行的，所以理论上适配任何一种<code>union</code>（独立）。但实际 union-by-size最适配路径压缩。路径压缩会改变树的高度，所以搭配union-by-height就有点复杂</p>
<blockquote>
<p>Path compression is performed during a find operation and is independent of the strategy used to perform unions. Path compression is perfectly compatible with union-by-size, and thus both routines can be implemented at the same time. Path compression is not entirely compatible with union-by-height, because path compression can change the heights of the trees.</p>
</blockquote>
<p>做法<br>查x，则将x到root的路径上所有结点都变成root的子女（包括x）</p>
<blockquote>
<p>Suppose the operation is find(x). Then the effect of path compression is that every node on the path from x to the root has its parent changed to the root.</p>
</blockquote>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>这里优化<code>union</code>采用union-by-size的方法，因此数组s[i]的含义为：<br>$s[i]&#x3D;\begin{cases}<br>元素i的parent &amp; i不是root\<br>树的结点总数（&lt;0，只有根节点时是-1） &amp; i是root\<br>\end{cases}$</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjSets</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DisjSets</span>() :<span class="built_in">size</span>(<span class="number">10</span>) &#123;</span><br><span class="line">		s = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)s[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DisjSets</span>(<span class="type">int</span> m) :<span class="built_in">size</span>(m) &#123;</span><br><span class="line">		s = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)s[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">DisjSets</span>() &#123; <span class="keyword">delete</span>[]s; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//未优化的find</span></span><br><span class="line">		<span class="type">int</span> root = x;</span><br><span class="line">		<span class="comment">//找x的根</span></span><br><span class="line">		<span class="keyword">while</span> (s[root] &gt;= <span class="number">0</span>)root = s[root];</span><br><span class="line">		<span class="keyword">return</span> root;<span class="comment">//返回x的根</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> root1, <span class="type">int</span> root2)</span> </span>&#123;<span class="comment">//未优化的union</span></span><br><span class="line">		<span class="keyword">if</span> (root1 == root2 || s[root1] &gt;= <span class="number">0</span> || s[root2] &gt;= <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//将root2变成root1的子女</span></span><br><span class="line">		s[root1] += s[root2];<span class="comment">//更新结点数</span></span><br><span class="line">		s[root2] = root1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">unionBySize</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2)</span> </span>&#123;<span class="comment">//优化union</span></span><br><span class="line">		<span class="comment">//合并x1所在的集合和x2所在的集合</span></span><br><span class="line">		<span class="type">int</span> root1 = <span class="built_in">find</span>(x1);</span><br><span class="line">		<span class="type">int</span> root2 = <span class="built_in">find</span>(x2);</span><br><span class="line">		<span class="keyword">if</span> (root1 == root2)<span class="keyword">return</span>;<span class="comment">//本来就在一个集合里，不用合并</span></span><br><span class="line">		<span class="keyword">if</span> (s[root1] &gt; s[root2]) &#123;<span class="comment">//root2的结点多，root1变成root2的子女</span></span><br><span class="line">			s[root2] += s[root1];</span><br><span class="line">			s[root1] = root2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//root1的结点多，root2变成root1的子女</span></span><br><span class="line">			s[root1] += s[root2];</span><br><span class="line">			s[root2] = root1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">CollapsingFind1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//压缩路径优化find，非递归</span></span><br><span class="line">		<span class="type">int</span> root = x;</span><br><span class="line">		<span class="keyword">while</span> (s[root] &gt;= <span class="number">0</span>)root = s[root];<span class="comment">//找到root</span></span><br><span class="line">		<span class="keyword">while</span> (x != root) &#123;<span class="comment">//从x开始将沿途结点变成root的子女</span></span><br><span class="line">			<span class="type">int</span> temp = s[x];<span class="comment">//保存x的父结点</span></span><br><span class="line">			s[x] = root;<span class="comment">//x变成root的子女</span></span><br><span class="line">			x = temp;<span class="comment">//往上继续改造</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">CollapsingFind2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//压缩路径优化find，递归</span></span><br><span class="line">		<span class="keyword">if</span> (s[x] &lt; <span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			s[x] = <span class="built_in">CollapsingFind2</span>(s[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>* s;</span><br><span class="line">	<span class="type">int</span> size;<span class="comment">//一般不会添加元素，不用设置curSize，new多大就有多少元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><ul>
<li>要求<ol>
<li>函数定义域包含所有的key</li>
<li>设哈希表有m个位置，则函数值域为0~m-1</li>
<li>计算出来的地址均匀分布在地址空间</li>
</ol>
</li>
</ul>
<h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><ul>
<li>Collision<blockquote>
<p>Two keys may hash to the same slot. We call this situation a collision.</p>
</blockquote>
</li>
<li>Load factor<blockquote>
<p>Given a hash table T with m slots that stores n elements, we define the load factor $\alpha$ for T as n&#x3D;m</p>
</blockquote>
</li>
</ul>
<h4 id="Chaining"><a href="#Chaining" class="headerlink" title="Chaining"></a>Chaining</h4><blockquote>
<p>In chaining, we place all the elements that hash to the same slot into the same linked list</p>
</blockquote>
<p><strong>注：当链表很长时，搜索效率降低，可以设计算法，当长度到一定值时，将链表转变成AVL或红黑树</strong></p>
<p><strong>代码</strong></p>
<ul>
<li>哈希函数：除留余数法</li>
<li>结点以键值对的形式</li>
<li>注意二级指针的用法</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//K:关键码的数据类型	V:value的数据类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChainNode</span> &#123;<span class="comment">//链地址结点</span></span><br><span class="line">	K key;<span class="comment">//关键码</span></span><br><span class="line">	V value;<span class="comment">//值</span></span><br><span class="line">	ChainNode&lt;K,V&gt;* next;</span><br><span class="line">	<span class="built_in">ChainNode</span>&lt;K, V&gt;():<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">	<span class="built_in">ChainNode</span>&lt;K, V&gt;(K k,V v):<span class="built_in">key</span>(k),<span class="built_in">value</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HashTable</span>() :<span class="built_in">divisor</span>(<span class="number">97</span>), <span class="built_in">tableSize</span>(<span class="number">100</span>) &#123; </span><br><span class="line">		<span class="comment">//全部初始化为nullprt（new出来的默认不是nullptr，要手动置空）</span></span><br><span class="line">		table = <span class="keyword">new</span> ChainNode&lt;K, V&gt;*[<span class="number">100</span>] &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">HashTable</span>(<span class="type">int</span> sz) :<span class="built_in">tableSize</span>(sz) &#123; </span><br><span class="line">		<span class="comment">//全部初始化为nullprt（new出来的默认不是nullptr，要手动置空）</span></span><br><span class="line">		table = <span class="keyword">new</span> ChainNode&lt;K, V&gt;*[sz] &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">		<span class="comment">//除数取不大于最大容量的素数</span></span><br><span class="line">		divisor = sz;</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">isPrime</span>(divisor))divisor--;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">HashTable</span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tableSize; i++)<span class="keyword">delete</span>[]table[i];</span><br><span class="line">		<span class="keyword">delete</span> []table;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(K key,V value)</span> </span>&#123;<span class="comment">//插入</span></span><br><span class="line">		<span class="comment">//通过哈希函数找到slot位置</span></span><br><span class="line">		<span class="type">int</span> pos = key % divisor;</span><br><span class="line">		ChainNode&lt;K, V&gt; *put = <span class="keyword">new</span> <span class="built_in">ChainNode</span>&lt;K, V&gt;(key, value);</span><br><span class="line">		<span class="comment">//插入操作</span></span><br><span class="line">		<span class="keyword">if</span> (table[pos] == <span class="literal">nullptr</span>)table[pos] = put;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ChainNode&lt;K, V&gt;* temp = table[pos];</span><br><span class="line">			<span class="keyword">while</span> (temp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="comment">//如果有重复value则插入失败</span></span><br><span class="line">				<span class="keyword">if</span> (value == temp-&gt;value)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			temp-&gt;next = put;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> K key, V&amp; value)</span> </span>&#123;<span class="comment">//搜索</span></span><br><span class="line">		<span class="comment">//按关键码寻找</span></span><br><span class="line">		ChainNode&lt;K, V&gt; *temp = <span class="built_in">Find</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找不到false</span></span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//找得到就获得对应的值，返回true</span></span><br><span class="line">			value = temp-&gt;value;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> K key, V&amp; value)</span> </span>&#123;<span class="comment">//删除</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Find</span>(key) == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没有这个数据，删除失败</span></span><br><span class="line">		<span class="type">int</span> pos = key % divisor;<span class="comment">//找到在表中哪个槽位</span></span><br><span class="line">		ChainNode&lt;K, V&gt;* pre = <span class="literal">nullptr</span>;<span class="comment">//被删结点的前驱</span></span><br><span class="line">		ChainNode&lt;K, V&gt;* temp = table[pos];<span class="comment">//被删结点</span></span><br><span class="line">		<span class="keyword">while</span> (temp-&gt;key != key) &#123;<span class="comment">//找被删结点</span></span><br><span class="line">			pre = temp;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) table[pos] = table[pos]-&gt;next;<span class="comment">//删除首结点时</span></span><br><span class="line">		<span class="keyword">else</span> pre-&gt;next = temp-&gt;next;<span class="comment">//否则，常规的链表删除</span></span><br><span class="line">		value = temp-&gt;value;<span class="comment">//保存被删结点的vlaue</span></span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> divisor;<span class="comment">//除数（必须质数）</span></span><br><span class="line">	ChainNode&lt;K, V&gt;** table;</span><br><span class="line">	<span class="type">int</span> tableSize;<span class="comment">//哈希表的slots总量</span></span><br><span class="line">	<span class="comment">//判断是否素数</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (d &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(d); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((d % i) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据关键码寻找，找到则返回结点，没找到则返回nullprt</span></span><br><span class="line">	<span class="function">ChainNode&lt;K, V&gt;* <span class="title">Find</span><span class="params">(<span class="type">const</span> K key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先找到是在哪个链表中</span></span><br><span class="line">		<span class="type">int</span> pos = key % divisor;</span><br><span class="line">		<span class="comment">//创指针指向key在的那个链表</span></span><br><span class="line">		ChainNode&lt;K, V&gt;* p = table[pos];</span><br><span class="line">		<span class="comment">//遍历找到关键码为key的元素并返回</span></span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;key == key)<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="Open-Addressing"><a href="#Open-Addressing" class="headerlink" title="Open Addressing"></a>Open Addressing</h4><blockquote>
<p>In open addressing, all elements occupy the hash table itself. That is, each table entry contains either an element of the dynamic set or NIL. When searching for an element, we systematically examine table slots until either we find the desired element or we have ascertained that the element is not in the table. No lists and no elements are stored outside the table, unlike in chaining. Thus, in open addressing, the hash table can “fill up” so that no further insertions can be made; one consequence is that the load factor $\alpha$ can never exceed 1.</p>
</blockquote>
<ul>
<li><strong>Linear probing</strong><ul>
<li>做法<br>位置冲突，则向后逐个找直到有空位置，将元素放入空位置</li>
<li>公式<br>假设H<del>0</del>&#x3D;Hash(key)冲突，则H<del>i</del>&#x3D;(H<del>0</del>+1)%m, i&#x3D;1,2,3,…,m-1</li>
</ul>
</li>
<li><strong>Quadratic probing</strong><ul>
<li>做法<br>位置冲突，则向后找距离为i^2^的位置，若有空位则安放；<br>若没空位置，则往前找距离为i^2^的位置…重复上述操作直到有位置放（$i&#x3D;1,2,3,…$）</li>
<li>要求<ol>
<li>表大小需满足4*k+3的质数</li>
<li>$\alpha$&lt;&#x3D;0.5时，新元素一定有位置可以插入，且任何位置不会被探查两次</li>
</ol>
</li>
<li>公式<br>假设H<del>0</del>&#x3D;Hash(key)冲突<br>H<del>i</del>&#x3D;(H<del>0</del>+i^2^)%m<br>H<del>i</del>&#x3D;(H<del>0</del>-i^2^)%m, i&#x3D;1,2,3,…m-1</li>
</ul>
</li>
<li><strong>Double hashing</strong><ul>
<li>做法<br>第一个哈希函数算基准位置，第二个哈希函数算偏移量</li>
<li>公式<br>j&#x3D;H<del>0</del>&#x3D;Hash(key),p&#x3D;ReHash(key)<br>H<del>i</del>&#x3D;(H<del>0</del>+i*p)%m, i&#x3D;1,2,3,…,m-1</li>
</ul>
</li>
</ul>
<p><strong>Open Adressing的删除操作比较特殊</strong></p>
<p><strong>代码（以Linear probing为例）</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//K:关键码的数据类型	V:value的数据类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span> &#123;<span class="comment">//哈希结点</span></span><br><span class="line">	K key;<span class="comment">//关键码</span></span><br><span class="line">	V value;<span class="comment">//值</span></span><br><span class="line">	<span class="type">bool</span> isActive=<span class="literal">false</span>;<span class="comment">//标志该结点是否处于激活状态：默认/被删除是false</span></span><br><span class="line">	<span class="built_in">HashNode</span>&lt;K, V&gt;():<span class="built_in">isActive</span>(<span class="literal">false</span>) &#123;&#125;;</span><br><span class="line">	<span class="built_in">HashNode</span>&lt;K, V&gt;(K k, V v) :<span class="built_in">key</span>(k), <span class="built_in">value</span>(v),<span class="built_in">isActive</span>(<span class="literal">true</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HashTable</span>() :<span class="built_in">divisor</span>(<span class="number">97</span>), <span class="built_in">tableSize</span>(<span class="number">100</span>) &#123;</span><br><span class="line">		table = <span class="keyword">new</span> HashNode&lt;K,V&gt;[<span class="number">100</span>];</span><br><span class="line">		currentSize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">HashTable</span>(<span class="type">int</span> sz) :<span class="built_in">tableSize</span>(sz) &#123; </span><br><span class="line">		table = <span class="keyword">new</span> HashNode&lt;K, V&gt;[sz] ;</span><br><span class="line">		<span class="comment">//除数取不大于最大容量的素数</span></span><br><span class="line">		divisor = sz;</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">isPrime</span>(divisor))divisor--;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">HashTable</span>() &#123;<span class="keyword">delete</span> []table;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(K key,V value)</span> </span>&#123;<span class="comment">//插入</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FindPos</span>(key) != <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="function">HashNode&lt;K, V&gt; <span class="title">s</span><span class="params">(key, value)</span></span>;</span><br><span class="line">		<span class="type">int</span> pos = key % divisor;</span><br><span class="line">		<span class="comment">//找插入位置：必须找到未被激活（使用）的位置</span></span><br><span class="line">		<span class="keyword">while</span> (table[pos].isActive==<span class="literal">true</span>)pos++;</span><br><span class="line">		table[pos] = s;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> K key, V&amp; value)</span> </span>&#123;<span class="comment">//搜索</span></span><br><span class="line">		<span class="type">int</span> pos = <span class="built_in">FindPos</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> value = table[pos].value;<span class="comment">//保存搜索到的元素值</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> K key, V&amp; value)</span> </span>&#123;<span class="comment">//删除</span></span><br><span class="line">		<span class="comment">//删除：将该位置设置为未激活状态</span></span><br><span class="line">		<span class="type">int</span> pos = <span class="built_in">FindPos</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//元素不在表里，删除失败</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			value = table[pos].value;<span class="comment">//保存被删元素的值</span></span><br><span class="line">			table[pos].isActive=<span class="literal">false</span>;<span class="comment">//将该位置标记为未激活状态</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> divisor;<span class="comment">//除数（必须质数）</span></span><br><span class="line">	HashNode&lt;K,V&gt;* table;</span><br><span class="line">	<span class="type">int</span> tableSize;<span class="comment">//哈希表的slots总量</span></span><br><span class="line">	<span class="type">int</span> currentSize;<span class="comment">//当前元素数量</span></span><br><span class="line">	<span class="comment">//判断是否素数</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (d &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(d); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((d % i) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据关键码寻找，找到则返回结点，没找到则返回nullprt</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">FindPos</span><span class="params">(<span class="type">const</span> K key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//通过哈希函数获得位置坐标，flag是为了保存这个原始位置</span></span><br><span class="line">		<span class="type">int</span> pos = key % divisor;</span><br><span class="line">		<span class="type">int</span> flag = pos;</span><br><span class="line">		<span class="keyword">while</span> (table[pos].key != key) &#123;</span><br><span class="line">			pos=(pos+<span class="number">1</span>)%tableSize;</span><br><span class="line">			<span class="keyword">if</span> (pos == flag)<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//找了一圈，又回到了最初的起点，说明不在哈希表里</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (table[pos].isActive == <span class="literal">false</span>)<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//匹配到了，但处于未激活状态（被删），也返回-1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> pos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h3 id="完美哈希"><a href="#完美哈希" class="headerlink" title="完美哈希"></a>完美哈希</h3><h2 id="B树B-树"><a href="#B树B-树" class="headerlink" title="B树B+树"></a>B树B+树</h2>
            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：搜索</li>
        <li>Post author：萧</li>
        <li>Create time：2023-01-20 13:28:48</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/01/20/数据结构笔记/Search/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Graph/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">图</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Tree/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">二叉树</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div style="font-size: 1.3rem;margin-top: 0; margin-bottom: 0.8rem; transition-duration: 0.1s;"><i class="fa-solid fa-list"></i> <strong>Contents</strong></div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2"><span class="nav-text">搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE"><span class="nav-text">前置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E5%B0%8F%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E8%AE%BE%E7%BD%AE%E7%9B%91%E8%A7%86%E5%93%A8"><span class="nav-text">顺序搜索小优化——设置监视哨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">基于有序数据的二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BST%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">BST二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AVL%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88%E4%BC%98%E5%8C%96BST%EF%BC%89"><span class="nav-text">AVL平衡树（优化BST）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DisJoint-Set-union-find-set%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">DisJoint Set(union-find set并查集)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE-1"><span class="nav-text">前置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%9AFind%E5%92%8CUnion"><span class="nav-text">两个基本操作：Find和Union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%A7%E8%83%BD"><span class="nav-text">优化并查集性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-text">散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81"><span class="nav-text">处理冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Chaining"><span class="nav-text">Chaining</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Open-Addressing"><span class="nav-text">Open Addressing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">性能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E5%93%88%E5%B8%8C"><span class="nav-text">完美哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B%E6%A0%91B-%E6%A0%91"><span class="nav-text">B树B+树</span></a></li></ol></li></ol>
    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">萧. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v0.5.2</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/8/17 11:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        

        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fa-solid fa-magnifying-glass-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fa-solid fa-magnifying-glass-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fa-solid fa-left-right"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fa-solid fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fa-solid fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fa-solid fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fa-solid fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>




    
<script src="/js/runtime.js"></script>

    
<script src="/js/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
