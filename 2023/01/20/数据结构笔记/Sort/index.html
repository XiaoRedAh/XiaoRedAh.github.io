<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="萧">
    <link rel="canonical" href="http://example.com/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Sort/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            排序 |
        
        等想好起什么名字后再来改
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"0.5.2","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">
    
    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                等想好起什么名字后再来改
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        主页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        存档记录
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories"  >
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/link2">LINK2
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/link3">LINK3
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                主页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                存档记录
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/categories"  >
                             
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link2">LINK2</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link3">LINK3</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:2rem; font-weight: bold; margin: 10px 0;">排序</h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">萧</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-01-20 13:28:48</span>
        <span class="mobile">2023-01-20 13:28</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic%5C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png"
                     
                ></p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png"
                     
                ></p>
<p><strong>算法稳定性</strong></p>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1&#x3D;A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p>
<p><strong>算法稳定性干啥的</strong></p>
<p>算法稳定性的意义一般体现在按不同标准多次排序的场景</p>
<p>比如一个班的学生已经按照学号大小排好序了，现在要求按照年龄从小到大再排个序，如果年龄相同的，必须按照学号从小到大的顺序排列。如果选择的年龄排序方法是不稳定的，排序完了后年龄相同的一组学生学号就乱了；如果是稳定的排序算法，就只需要按照年龄排一遍就好了。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*直接插入排序：将有序数列外的元素插入有序数列，使有序数列一步步扩大，直至</span></span><br><span class="line"><span class="comment">	全体有序，即完成排序*/</span></span><br><span class="line">	<span class="comment">//初始时，默认第一个元素构成有序序列，因此第一个插入的元素是第二个元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = begin + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="type">int</span> temp = v[i];<span class="comment">//暂存待插入元素</span></span><br><span class="line">		<span class="type">int</span> j = i;<span class="comment">//j就是插入的位置，默认插在有序序列尾（待查元素本来的位置）</span></span><br><span class="line">		<span class="comment">//开始找位置</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt; begin &amp;&amp; v[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">			v[j] = v[j - <span class="number">1</span>];<span class="comment">//找位置的同时移位</span></span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		v[j] = temp;<span class="comment">//找到v[j-1]&lt;temp,插到它后面，即插入到v[j]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>一种优化的插入排序算法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*将距离为gap的整数倍的元素划分在一个子序列，对这些子序列进行直接插入排序</span></span><br><span class="line"><span class="comment">	使它们有序，然后缩小gap，重新划分，重复上述步骤，直至gap=1的划分全部排好序，</span></span><br><span class="line"><span class="comment">	集合全体就排号序了*/</span></span><br><span class="line">	<span class="comment">//其实就是比直接插入排序外层多了个用于更新gap的循环，在比较和挪位时衡量的长度变为gap</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> gap = (begin + end) / <span class="number">2</span>+<span class="number">1</span>; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//实际上就是比较和挪位时衡量的长度变为gap的直接插入排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = begin + gap; i &lt;= end; i++) &#123;</span><br><span class="line">			<span class="type">int</span> temp = v[i];</span><br><span class="line">			<span class="type">int</span> j = i;</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= begin+gap &amp;&amp; v[j - gap] &gt; temp) &#123;<span class="comment">//这里条件时&gt;=</span></span><br><span class="line">				v[j] = v[j - gap];</span><br><span class="line">				j=j-gap;</span><br><span class="line">			&#125;</span><br><span class="line">			v[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>注：以最小堆为例</p>
<p><strong>最初的思路</strong></p>
<p>最小堆的第一个元素是min，那就<code>deleteMin</code>得到min，将它放到另一个数组<code>temp</code>里，一直重复操作,temp里的元素就是有序的，最后将temp的元素<code>copy</code>回原数组</p>
<p><strong>优化一下——不额外开辟空间</strong></p>
<p>将堆第一个元素和堆最后一个元素交换，然后堆大小-1，调整堆序性，不断重复上述操作直至堆大小为0</p>
<p>这样操作可以避免额外开辟空间，用最小堆进行堆排序得到递减序列，用最大堆进行堆排序得到递增序列</p>
<p><strong>代码</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(T* arr,<span class="type">int</span> start, <span class="type">int</span> PosLastNode)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> PosFather = start;</span><br><span class="line">	<span class="type">int</span> PosChild = <span class="number">2</span> * start + <span class="number">1</span>;</span><br><span class="line">	T fatherKey = arr[PosFather];</span><br><span class="line">	<span class="keyword">while</span> (PosChild &lt;= PosLastNode) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PosChild&lt;PosLastNode &amp;&amp; arr[PosChild]&gt;arr[PosChild + <span class="number">1</span>])</span><br><span class="line">			PosChild++;</span><br><span class="line">		<span class="keyword">if</span> (arr[PosFather] &lt;= arr[PosChild])<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (arr[PosFather] &gt; arr[PosChild]) &#123;</span><br><span class="line">			arr[PosFather] = arr[PosChild];</span><br><span class="line">			arr[PosChild] = fatherKey;</span><br><span class="line">			PosFather = <span class="number">2</span> * PosFather + <span class="number">1</span>;</span><br><span class="line">			PosChild = <span class="number">2</span> * PosFather + <span class="number">1</span>;</span><br><span class="line">			fatherKey = arr[PosFather];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(T* arr, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先将传入的数组调整为堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = (length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		<span class="built_in">siftDown</span>(arr, i, length - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//将最小元素和堆最后一个元素交换位置，堆大小-1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">1</span>; i &gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">siftDown</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>divide-and-conquer分治思想(以二路归并为例)</strong></p>
<p>要排序全集S，就将全集S的前一半元素划分为S1，后一半元素划分为S2，排序S1，S2（这个排序也是遵从上面的策略），最后将有序的S1和S2合并成有序的全集S</p>
<p>从上面描述可知，归并排序就是将要排序的集合一步步划分为小集合，当这些小集合有序后，一步步返回合并为规模更大的有序集合，最终合并为有序的全集</p>
<p>因此可以用递归的方式实现递归算法：一步步将问题划分为更小的子问题，在返回（归）的过程中合并</p>
<p><strong>怎么合并两个有序集合</strong></p>
<blockquote>
<p>The basic merging algorithm takes two input arrays A and B, an output array C, and three counters, Actr, Bctr, and Cctr, which are initially set to the beginning of their respective arrays. The smaller of A[Actr] and B[Bctr] is copied to the next entry in C, and the appropriate counters are advanced. When either input list is exhausted, the remainder of the other list is copied to C</p>
</blockquote>
<p>写代码时，可以用一个暂存数组保存合并的结果，然后将暂存数组返回给原来的数组</p>
<p><strong>代码（二路归并）</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span>* temp, <span class="type">int</span> begin, <span class="type">int</span> mid ,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tempPos = begin;<span class="comment">//暂存数组的起始位置：S1的起始</span></span><br><span class="line">	<span class="type">int</span> leftStart = begin;<span class="comment">//S1的起始位置</span></span><br><span class="line">	<span class="type">int</span> leftEnd = mid;<span class="comment">//S1的终止位置</span></span><br><span class="line">	<span class="type">int</span> rightStart = mid + <span class="number">1</span>;<span class="comment">//S2的起始位置</span></span><br><span class="line">	<span class="type">int</span> rightEnd = end;<span class="comment">//S2的终止位置</span></span><br><span class="line">	<span class="type">int</span> N = end - begin + <span class="number">1</span>;<span class="comment">//记录S1和S2一共有多少元素</span></span><br><span class="line">	<span class="type">int</span> i = leftStart;<span class="comment">//指针i遍历S1</span></span><br><span class="line">	<span class="type">int</span> j = rightStart;<span class="comment">//指针j遍历S2</span></span><br><span class="line">	<span class="comment">//i，j分别遍历有序集合S1和S2，将小的放到暂存数组</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= leftEnd &amp;&amp; j &lt;= rightEnd) &#123;<span class="comment">//终止：S1或S2的所有元素都放到暂存数组了</span></span><br><span class="line">		<span class="keyword">if</span> (v[i] &lt; v[j])temp[tempPos++] = v[i++];</span><br><span class="line">		<span class="keyword">else</span> temp[tempPos++] = v[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= leftEnd) temp[tempPos++] = v[i++];<span class="comment">//将S1剩余的元素放入暂存数组</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt;= rightEnd) temp[tempPos++] = v[j++];<span class="comment">//将S2剩余的元素放入暂存数组</span></span><br><span class="line">	<span class="comment">//经过上述操作，暂存数组的begin到end这部分就是有序的，将它放回数组v</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = begin; k &lt; begin+N; k++)v[k] = temp[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span>* temp,<span class="type">int</span> begin,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end)<span class="keyword">return</span>;<span class="comment">//划分的集合里只有0或1个元素，不用排序直接返回</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = (begin + end) / <span class="number">2</span>;<span class="comment">//二路归并，将集合S划分为S1和S2</span></span><br><span class="line">		<span class="built_in">mergeSort</span>(v, temp, begin, mid);<span class="comment">//排序前一半元素S1</span></span><br><span class="line">		<span class="built_in">mergeSort</span>(v, temp, mid + <span class="number">1</span>, end);<span class="comment">//排序后一半元素S2</span></span><br><span class="line">		<span class="built_in">merge</span>(v, temp, begin, mid, end);<span class="comment">//将这两部分元素合并为一个有序序列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>经典冒泡</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*冒泡排序：要排序的数据有n个，则需要排n-1轮,每轮轮比完会将序列分</span></span><br><span class="line"><span class="comment">      为无序区和有序区两个区间，每轮排序都将最大元素交换到了最后（有序区的首位置），</span></span><br><span class="line"><span class="comment">	  每轮排序从begin开始相邻数据两两比较，若反序则交换，直到无序区比较完无序区</span></span><br><span class="line"><span class="comment">	  的最后两个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="type">bool</span> exchange;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end - begin; i++) &#123;<span class="comment">//排n-1轮</span></span><br><span class="line">		exchange = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = begin; j &lt; end - i; j++) &#123;<span class="comment">//每轮排序的逻辑</span></span><br><span class="line">			<span class="keyword">if</span> (v[j] &gt; v[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(v[j], v[j + <span class="number">1</span>]);</span><br><span class="line">				exchange = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (exchange == <span class="literal">false</span>)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优化冒泡</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>和归并排序一样，快排也采用 divide-and conquer 思想，可以用递归算法实现</strong></p>
<p><strong>对比归并排序的优势在于子问题的规模不要求一样大</strong></p>
<blockquote>
<p>Like mergesort, it recursively solves two subproblems and requires linear additional work (step 3), but, unlike mergesort, the subproblems are not guaranteed to be of equal size, which is potentially bad. The reason that quicksort is faster is that the partitioning step can actually be performed in place and very efficiently. This efficiency more than makes up for the lack of equal-sized recursive calls.</p>
</blockquote>
<p><strong>典型的快排包括以下四步</strong></p>
<p>从集合里拿出一个参照物（pivot），然后将剩余元素分成两部分（partition）：所有元素&lt;&#x3D;pivot的区域S1和所有元素均&gt;&#x3D;pivot的区域S2,最终返回S1+pivot+S2</p>
<blockquote>
<p>1、If the number of elements in S is 0 or 1, then return.<br>2、Pick any element v in S. This is called the pivot.<br>3、Partition S − {v} (the remaining elements in S) into two disjoint groups: S1 &#x3D; {x ∈S − {v}|x ≤ v}, and S2 &#x3D; {x ∈ S − {v}|x ≥ v}.<br>4、 Return {quicksort(S1) followed by v followed by quicksort(S2)}</p>
</blockquote>
<p>step2和step3实现的方法有很多种</p>
<p><strong>step2：如何选择参照物pivot</strong></p>
<ul>
<li><p>不要选第一个元素作为pivot:<br>多数情况下，我们的输入是有序或部分有序的，这个时候挑选第一个元素作pivot，根据它分区会很不理想（因为两个分区元素数量差距会很悬殊，甚至有一个分区没有元素），这会导致浪费很多时间做无用的事</p>
<blockquote>
<p>if the input is presorted or in reverse order, then the pivot provides a poor partition, because either all the elements go into S1 or they go into S2.</p>
</blockquote>
</li>
<li><p>最好的选择：从集合中找三个元素（一般是begin，mid，end），取它们的中位数作pivot</p>
</li>
</ul>
<p><strong>step3：partiton</strong></p>
<p><strong>代码</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">int</span> begin,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> midPos = (begin + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">/*将三者的中位数选为pivot，移到v[end], 排序时就排begin到end - 1这个区间的数,</span></span><br><span class="line"><span class="comment">	这是为了将pivot剔除出待排序的全集，等区间内的元素排好序后再将pivot接回来*/</span></span><br><span class="line">	<span class="keyword">if</span> (v[begin] &gt; v[midPos])<span class="built_in">swap</span>(v[begin], v[midPos]);</span><br><span class="line">	<span class="keyword">if</span> (v[end] &gt; v[midPos])<span class="built_in">swap</span>(v[midPos], v[end]);</span><br><span class="line">	<span class="keyword">if</span> (v[begin] &gt; v[end])<span class="built_in">swap</span>(v[begin], v[end]);</span><br><span class="line">	<span class="keyword">return</span> v[end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end)<span class="keyword">return</span>;<span class="comment">//若待排序的集合只有0或1个元素，直接返回</span></span><br><span class="line">	<span class="type">int</span> pivot = <span class="built_in">partition</span>(v,begin,end);<span class="comment">//获得pivot，并将pivot剔除出待排序集合</span></span><br><span class="line">	<span class="comment">/*指针i从头出发，在元素&gt;pivot的地方停下，指针j从尾出发，在元素&lt;pivot的地方停下，</span></span><br><span class="line"><span class="comment">	交换两指针所指元素，然后重复上述操作直到i和j相遇或i超过j。*/</span></span><br><span class="line">	<span class="type">int</span> i = begin<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> j = end;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (v[++i] &lt; pivot) &#123;&#125;</span><br><span class="line">		<span class="keyword">while</span> (v[--j] &gt; pivot) &#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)<span class="built_in">swap</span>(v[i], v[j]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*i &gt;= j, 这一轮排序结束，把pivot接回来，放在v[i]位置，这样保障了i左侧所有元素</span></span><br><span class="line"><span class="comment">	 小于pivot，i右侧所有元素大于pivot*/</span></span><br><span class="line">	<span class="built_in">swap</span>(v[i], v[end]);</span><br><span class="line">	<span class="comment">//经过上面操作，以pivot为参照，划分了S1和S2，现在分别对它们再继续进行快排</span></span><br><span class="line">	<span class="built_in">quickSort</span>(v, begin, i - <span class="number">1</span>);<span class="comment">//对S1快排</span></span><br><span class="line">	<span class="built_in">quickSort</span>(v, i + <span class="number">1</span>, end);<span class="comment">//对S2快排</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>优化快排</strong></p>
<p>快排在数据量小（N&lt;&#x3D;20）的时候效率一般。我们可以在一开始数据量很大时用快排，当子序列的数据量缩小到一定值(5~15之间)，就转而用插入排序或其他在数据量小时效率更高的排序算法</p>
<blockquote>
<p>A common solution is not to use quicksort recursively for small arrays, but instead use a sorting algorithm that is efficient for small arrays, such as insertion sort. Using this strategy can actually save about 15 percent in the running time (over doing no cutoff at all). A good cutoff range is N &#x3D; 10, although any cutoff between 5 and 20 is likely to produce similar results. This also saves nasty degenerate cases, such as taking the median of three elements when there are only one or two.</p>
</blockquote>
<p>下面给出直接插入和快排混合算法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickInsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//数据量小的时候转而用直接插入排序</span></span><br><span class="line">	<span class="keyword">if</span> (end - begin &lt;= <span class="number">10</span>) <span class="built_in">insertSort</span>(v, begin, end);</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//数据量大的时候用快排</span></span><br><span class="line">		<span class="type">int</span> pivot = <span class="built_in">partition</span>(v, begin, end);</span><br><span class="line">		<span class="type">int</span> i = begin - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> j = end;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (v[++i] &lt; pivot) &#123;&#125;</span><br><span class="line">			<span class="keyword">while</span> (v[--j] &gt; pivot) &#123;&#125;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; j)<span class="built_in">swap</span>(v[i], v[j]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(v[i], v[end]);</span><br><span class="line">		<span class="built_in">quickInsertSort</span>(v, begin, i - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">quickInsertSort</span>(v, i + <span class="number">1</span>, end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*直接选择排序：在v[i]到v[end]中找到最小元素的位置（初始时i=begin），</span></span><br><span class="line"><span class="comment">	让它和第一个元素v[i]对调，然后i++，重复上述操作，当i=end-1时，全体排好序*/</span></span><br><span class="line">	<span class="comment">/*将数组看成左边的有序集合S1与右边的无序集合S2，将无序集合S2的最小元素v移动到</span></span><br><span class="line"><span class="comment">	S2首位置，那么v就自动加入到了S1，这时的S2就是原先的S2剔除掉首元素，重复上述</span></span><br><span class="line"><span class="comment">	操作，直到S1为全集，S2为空集，排序完成*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">		<span class="type">int</span> minPos = i;<span class="comment">//记录无序集合S2中最小元素的位置（默认为S2首元素）</span></span><br><span class="line">		<span class="comment">//开始找最小元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= end; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[j] &lt; v[minPos])minPos = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找到最小元素位置，如果最小元素不是S2的首元素，就移到首元素，否则不用动</span></span><br><span class="line">		<span class="keyword">if</span> (minPos != i)<span class="built_in">swap</span>(v[i], v[minPos]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Bucket-Sort桶排序"><a href="#Bucket-Sort桶排序" class="headerlink" title="Bucket Sort桶排序"></a>Bucket Sort桶排序</h2><h2 id="Counting-Sort基数排序"><a href="#Counting-Sort基数排序" class="headerlink" title="Counting Sort基数排序"></a>Counting Sort基数排序</h2><h2 id="Radix-Sort基数排序"><a href="#Radix-Sort基数排序" class="headerlink" title="Radix Sort基数排序"></a>Radix Sort基数排序</h2><h2 id="链表实现排序算法"><a href="#链表实现排序算法" class="headerlink" title="链表实现排序算法"></a>链表实现排序算法</h2><p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/TenosDoIt/p/3666585.html" >https://www.cnblogs.com/TenosDoIt/p/3666585.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h1>
            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：排序</li>
        <li>Post author：萧</li>
        <li>Create time：2023-01-20 13:28:48</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/01/20/数据结构笔记/Sort/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Queue/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">队列应用</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Search/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">搜索</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div style="font-size: 1.3rem;margin-top: 0; margin-bottom: 0.8rem; transition-duration: 0.1s;"><i class="fa-solid fa-list"></i> <strong>Contents</strong></div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%8E%92%E5%BA%8F"><span class="nav-text">内排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E8%A7%88"><span class="nav-text">总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-text">性能对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">希尔排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">直接选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bucket-Sort%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">Bucket Sort桶排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Counting-Sort%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">Counting Sort基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Radix-Sort%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">Radix Sort基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">链表实现排序算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%96%E6%8E%92%E5%BA%8F"><span class="nav-text">外排序</span></a></li></ol>
    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">萧. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v0.5.2</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/8/17 11:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        

        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fa-solid fa-magnifying-glass-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fa-solid fa-magnifying-glass-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fa-solid fa-left-right"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fa-solid fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fa-solid fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fa-solid fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fa-solid fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>




    
<script src="/js/runtime.js"></script>

    
<script src="/js/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
