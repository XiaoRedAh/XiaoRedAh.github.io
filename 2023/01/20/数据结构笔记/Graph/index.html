<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="萧">
    <link rel="canonical" href="http://example.com/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Graph/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            Graph |
        
        等想好起什么名字后再来改
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"0.5.2","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">
    
    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                等想好起什么名字后再来改
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        主页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        存档记录
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories"  >
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/link2">LINK2
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/link3">LINK3
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                主页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                存档记录
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/categories"  >
                             
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link2">LINK2</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link3">LINK3</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:2rem; font-weight: bold; margin: 10px 0;">Graph</h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">萧</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-01-20 13:28:48</span>
        <span class="mobile">2023-01-20 13:28</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%9B%BE/">图</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="还没想好写什么"><a href="#还没想好写什么" class="headerlink" title="还没想好写什么"></a>还没想好写什么</h2><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>操作一个图的基本函数<br><code>getValue(int pos)</code>:获得指定顶点的值<br><code>getWeight(int v1, int v2)</code>:获得(v1,v2)的权值<br><code>getFirstNeighbor(int v1)</code>:找到给定顶点的第一个邻接顶点的位置<br><code>addVertice(V vertice)</code>:添加结点<br><code>addEdge(int v1, int v2, double w)</code>:添加边(v1,v2),权值为w<br><code>removeVertice(int vPos)</code>:删除指定顶点v<br><code>removeEdge(int v1, int v2)</code>:删除边(v1,v2)</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>需要用邻接矩阵adjMatrix[i][j]存储v[i]和v[j]间的权值，用verticeList数组存储顶点值</p>
<p>带权值的图邻接矩阵定义如下<br>$$adjMatrix[i][j]&#x3D;\begin{cases}<br>v[i]和v[j]之间边的权值 &amp; i!&#x3D;j且两顶点间有边\<br>INF &amp; 两顶点间没边\<br>0 &amp; i&#x3D;&#x3D;j<br>\end{cases}$$</p>
<p>代码<br>实现的是带权图，构造时可选有向图或无向图<br>类模板用的是两个参数，但似乎权值给定<code>double</code>类型就行了，反正在写的时候都是默认<code>double</code>，两个类模板似乎多余了</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Queue.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*0x7fffffff恰好是int型的上界，所以一般情况下用它表示无穷大是一个很好的选择</span></span><br><span class="line"><span class="comment">但是在求图的最短路径时，往往需要进行无穷大数的比较，</span></span><br><span class="line"><span class="comment">而0x7fffffff再加上一个正数会溢出，成为负数，</span></span><br><span class="line"><span class="comment">所以一般情况下，定义为0x3fffffff或者0x3f3f3f3f 就能满足要求*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f<span class="comment">//定义无穷大</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;<span class="comment">//分别代表顶点和边的数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAM</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GraphAM</span>() :<span class="built_in">isDirected</span>(<span class="literal">false</span>),<span class="built_in">maxNumVertices</span>(<span class="number">20</span>), <span class="built_in">curNumVertices</span>(<span class="number">0</span>), <span class="built_in">curNumEdges</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		verticesList = <span class="keyword">new</span> V[maxNumVertices];</span><br><span class="line">		adjMatrix = <span class="keyword">new</span> E * [maxNumVertices];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNumVertices; i++) adjMatrix[i] = <span class="keyword">new</span> E[maxNumVertices];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNumVertices; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxNumVertices; j++) &#123;</span><br><span class="line">				adjMatrix[i][j] = (i == j) ? <span class="number">0</span> : INF;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">GraphAM</span>(<span class="type">bool</span> isDir,<span class="type">int</span> max) :<span class="built_in">isDirected</span>(isDir),<span class="built_in">maxNumVertices</span>(max), <span class="built_in">curNumVertices</span>(<span class="number">0</span>), <span class="built_in">curNumEdges</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		verticesList = <span class="keyword">new</span> V[maxNumVertices];</span><br><span class="line">		adjMatrix = <span class="keyword">new</span> E * [maxNumVertices];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNumVertices; i++) adjMatrix[i] = <span class="keyword">new</span> E[maxNumVertices];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNumVertices; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxNumVertices; j++) &#123;</span><br><span class="line">				adjMatrix[i][j] = (i == j) ? <span class="number">0</span> : INF;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">GraphAM</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[]verticesList;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNumVertices; i++) <span class="keyword">delete</span>[]adjMatrix[i];</span><br><span class="line">		<span class="keyword">delete</span>[]adjMatrix;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;<span class="comment">//顶点满了，扩充</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCurNumVertices</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> curNumVertices; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCurNumEdges</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> curNumEdges; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getVerPos</span><span class="params">(V vertice)</span> </span>&#123;<span class="comment">//获得指定顶点的位置</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (verticesList[i] == vertice)<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">V <span class="title">getValue</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;<span class="comment">//获得指定顶点的值</span></span><br><span class="line">		<span class="keyword">if</span> (pos &gt;= <span class="number">0</span> &amp;&amp; pos &lt; curNumVertices)</span><br><span class="line">			<span class="keyword">return</span> verticesList[pos];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">E <span class="title">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;<span class="comment">//获得(v1,v2)的权值</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices || v2 &lt; <span class="number">0</span> || v2 &gt;= curNumVertices)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> adjMatrix[v1][v2];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="type">int</span> v1)</span> </span>&#123;<span class="comment">//找到给定顶点的第一个邻接顶点的位置</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; curNumVertices; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (adjMatrix[v1][j] &gt; <span class="number">0</span> &amp;&amp; adjMatrix[v1][j] &lt; INF)<span class="keyword">return</span> j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="type">int</span> vStart, <span class="type">int</span> v)</span> </span>&#123;<span class="comment">//返回vStart顶点的邻接顶点v之后的下一个邻接顶点的位置</span></span><br><span class="line">		<span class="keyword">if</span> (vStart &lt; <span class="number">0</span> || vStart &gt;= curNumVertices || v &lt; <span class="number">0</span> || v &gt;= curNumVertices)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> col = v + <span class="number">1</span>; col &lt; curNumVertices; col++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (adjMatrix[vStart][col] &gt; <span class="number">0</span> &amp;&amp; adjMatrix[vStart][col] &lt; INF)<span class="keyword">return</span> col;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">addVertice</span><span class="params">(V vertice)</span> </span>&#123;<span class="comment">//添加结点</span></span><br><span class="line">		<span class="comment">//结点数量达到上限就扩容</span></span><br><span class="line">		<span class="keyword">if</span> (curNumVertices == maxNumVertices)<span class="built_in">extend</span>();</span><br><span class="line">		verticesList[curNumVertices++] = vertice;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, E w)</span> </span>&#123;<span class="comment">//添加边(v1,v2),权值为w</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices || v2 &lt; <span class="number">0</span> || v2 &gt;= curNumVertices)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果v1和v2本来就有边，添加失败</span></span><br><span class="line">			<span class="keyword">if</span> (adjMatrix[v1][v2] &gt; <span class="number">0</span> &amp;&amp; adjMatrix[v1][v2] &lt; INF)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">//添加成功</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(isDirected ==<span class="literal">false</span>)adjMatrix[v1][v2] = adjMatrix[v2][v1] = w;<span class="comment">//有向图</span></span><br><span class="line">				<span class="keyword">else</span> adjMatrix[v1][v2]=w;<span class="comment">//无向图</span></span><br><span class="line">				curNumEdges++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">removeVertice</span><span class="params">(<span class="type">int</span> vPos)</span> </span>&#123;<span class="comment">//删除指定顶点v</span></span><br><span class="line">		<span class="comment">//只有一个顶点，或顶点位置不存在，都删除失败</span></span><br><span class="line">		<span class="keyword">if</span> (curNumVertices == <span class="number">1</span> || vPos&lt;<span class="number">0</span> || vPos&gt;curNumVertices)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//集体移动的话邻接矩阵更新工作量就大，可以用最后一个顶点代替被删顶点</span></span><br><span class="line">		verticesList[vPos] = verticesList[curNumVertices - <span class="number">1</span>];</span><br><span class="line">		curNumVertices--;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="comment">//如果被删顶点v和顶点i有边，则删除边(记录边数-1)</span></span><br><span class="line">			<span class="keyword">if</span> (adjMatrix[vPos][i] &gt; <span class="number">0</span> &amp;&amp; adjMatrix[vPos][i] &lt; INF)curNumEdges--;</span><br><span class="line">			<span class="comment">//将被删顶点的边信息更换成代替过来的顶点（最后一个顶点）的边信息</span></span><br><span class="line">			<span class="keyword">if</span> (isDirected == <span class="literal">false</span>) &#123;<span class="comment">//无向图</span></span><br><span class="line">				<span class="keyword">if</span> (i != vPos)adjMatrix[vPos][i] = adjMatrix[i][vPos] = adjMatrix[curNumVertices][i];</span><br><span class="line">				<span class="keyword">if</span> (i == vPos)adjMatrix[vPos][i] = adjMatrix[i][vPos] = adjMatrix[curNumVertices][curNumVertices];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//有向图</span></span><br><span class="line">				<span class="keyword">if</span> (i != vPos) &#123;</span><br><span class="line">					adjMatrix[vPos][i] = adjMatrix[curNumVertices][i];</span><br><span class="line">					adjMatrix[i][vPos] = adjMatrix[i][curNumVertices];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i == vPos)adjMatrix[vPos][i] = adjMatrix[i][vPos] = adjMatrix[curNumVertices][curNumVertices];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;<span class="comment">//删除边(v1,v2)</span></span><br><span class="line">		<span class="comment">//顶点位置错误或本来就没边，删除失败</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices || v2 &lt; <span class="number">0</span> || v2 &gt;= curNumVertices)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (adjMatrix[v1][v2] == <span class="number">0</span> || adjMatrix[v1][v2] == INF)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isDirected == <span class="literal">false</span>) &#123;<span class="comment">//无向图</span></span><br><span class="line">				adjMatrix[v1][v2] = adjMatrix[v2][v1] = INF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> adjMatrix[v1][v2] = INF;<span class="comment">//有向图</span></span><br><span class="line">			curNumEdges--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; curNumVertices; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (adjMatrix[i][j] == INF)cout &lt;&lt; <span class="string">&quot;#&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				<span class="keyword">else</span> cout &lt;&lt; adjMatrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				<span class="keyword">if</span> (j == curNumVertices - <span class="number">1</span>)cout &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;顶点&quot;</span> &lt;&lt; verticesList[i] &lt;&lt; <span class="string">&quot;的邻接顶点：&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; curNumVertices; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (adjMatrix[i][j] != INF &amp;&amp; adjMatrix[i][j] != <span class="number">0</span>)</span><br><span class="line">					cout &lt;&lt; verticesList[j] &lt;&lt; <span class="string">&quot;(权值&quot;</span> &lt;&lt; adjMatrix[i][j] &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(V ver)</span> </span>&#123;<span class="comment">//从给定的顶点ver开始搜索</span></span><br><span class="line">		<span class="type">int</span>* flag = <span class="keyword">new</span> <span class="type">int</span>[curNumVertices] &#123;<span class="number">0</span>&#125;;<span class="comment">//记录顶点是否已经遍历过</span></span><br><span class="line">		<span class="type">int</span> pos = <span class="built_in">getVerPos</span>(ver);<span class="comment">//起点</span></span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(pos, flag);</span><br><span class="line">		<span class="comment">//这个图可能是不连通的，还有些顶点没遍历到：以没遍历到的顶点为起点继续遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)<span class="built_in">DFS</span>(i, flag);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(V ver)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> start = <span class="built_in">getVerPos</span>(ver);<span class="comment">//找位置，没有该顶点就直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (start == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		V val;<span class="comment">//用来暂存出队顶点</span></span><br><span class="line">		Queue&lt;V&gt; s;<span class="comment">//搜索时用到的队列</span></span><br><span class="line">		<span class="comment">//flag标记是否遍历过，为了自己调用自己时保存先前记录，因此用static变量</span></span><br><span class="line">		<span class="type">static</span> <span class="type">int</span>* flag = <span class="keyword">new</span> <span class="type">int</span>[curNumVertices] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		s.<span class="built_in">EnQueue</span>(ver);<span class="comment">//先将起点入队</span></span><br><span class="line">		flag[start] = <span class="number">1</span>;<span class="comment">//标记起点已遍历过</span></span><br><span class="line">		<span class="keyword">while</span> (!s.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">			s.<span class="built_in">DeQueue</span>(val);</span><br><span class="line">			start = <span class="built_in">getVerPos</span>(val);<span class="comment">//以出队顶点为起点，向外搜索一层</span></span><br><span class="line">			cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="type">int</span> p = <span class="built_in">getFirstNeighbor</span>(start);</span><br><span class="line">			<span class="comment">//将所有与出队顶点相邻的顶点（未遍历）入队</span></span><br><span class="line">			<span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flag[p] == <span class="number">0</span>) &#123;</span><br><span class="line">					s.<span class="built_in">EnQueue</span>(verticesList[p]);</span><br><span class="line">					flag[p] = <span class="number">1</span>;<span class="comment">//入队时就标记</span></span><br><span class="line">				&#125;</span><br><span class="line">				p = <span class="built_in">getNextNeighbor</span>(start, p);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这个图可能是不连通的，还有些顶点没遍历到：以没遍历到的顶点为起点继续遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)<span class="built_in">BFS</span>(<span class="built_in">getValue</span>(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> isDirected;<span class="comment">//false为无向图，true为有向图</span></span><br><span class="line">	V* verticesList;<span class="comment">//顶点表</span></span><br><span class="line">	E** adjMatrix;<span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="type">int</span> maxNumVertices;<span class="comment">//最大顶点数</span></span><br><span class="line">	<span class="type">int</span> curNumVertices;<span class="comment">//当前顶点数</span></span><br><span class="line">	<span class="type">int</span> curNumEdges;<span class="comment">//当前边数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span>*flag)</span> </span>&#123;</span><br><span class="line">		flag[pos] = <span class="number">1</span>;<span class="comment">//记录这个顶点遍历到了</span></span><br><span class="line">		cout &lt;&lt;<span class="built_in">getValue</span>(pos)&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出</span></span><br><span class="line">		<span class="comment">//如果这个顶点有邻接顶点，就继续DFS；否则就返回</span></span><br><span class="line">		<span class="type">int</span> p = <span class="built_in">getFirstNeighbor</span>(pos);</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//对当下顶点的每个邻接顶点进行DFS</span></span><br><span class="line">			<span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flag[p] == <span class="number">0</span>)<span class="built_in">DFS</span>(p, flag);</span><br><span class="line">				p = <span class="built_in">getNextNeighbor</span>(pos, p);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%9B%BE%E7%A4%BA.png"
                     
                ><br>该存储结构有两个表，一个是存放顶点的顶点表（数组），一个是存放边结点的边表（单链表）。</p>
<p>顶点结构体属性包括：顶点的值，指向边表的指针。<br>边结点结构体属性包括：边的另一个顶点的位置，边的权值，和一个next指针</p>
<p>代码<br>实现的是带权图，构造时可选择有向图或无向图<br>这里权值我直接默认是<code>double</code>类型，所以类模板就一个参数了<br>邻接表在删边，删结点的时候比较繁琐<br><strong>删边，删结点在有向图时有bug，有时间再来改</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Queue.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f<span class="comment">//定义无穷大</span></span></span><br><span class="line"><span class="comment">//构成边表的结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> anotherVer;<span class="comment">//另一个顶点在顶点表里的位置</span></span><br><span class="line">	<span class="type">double</span> weight;<span class="comment">//边的权值</span></span><br><span class="line">	EdgeNode* next;</span><br><span class="line">	<span class="built_in">EdgeNode</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">EdgeNode</span>(<span class="type">int</span> v, <span class="type">double</span> w) :<span class="built_in">anotherVer</span>(v), <span class="built_in">weight</span>(w), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertice</span> &#123;</span><br><span class="line">	V value;<span class="comment">//顶点的值</span></span><br><span class="line">	EdgeNode* adj;<span class="comment">//邻接边表</span></span><br><span class="line">	<span class="built_in">Vertice</span>() :<span class="built_in">adj</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAL</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GraphAL</span>() :<span class="built_in">isDirected</span>(<span class="literal">false</span>),<span class="built_in">maxNumVertices</span>(<span class="number">20</span>), <span class="built_in">curNumVertices</span>(<span class="number">0</span>), <span class="built_in">curNumEdges</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		verNodeTable = <span class="keyword">new</span> Vertice&lt;V&gt;[maxNumVertices];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">GraphAL</span>(<span class="type">bool</span> isDir,<span class="type">int</span> max) :<span class="built_in">isDirected</span>(isDir),<span class="built_in">maxNumVertices</span>(max), <span class="built_in">curNumVertices</span>(<span class="number">0</span>), <span class="built_in">curNumEdges</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		verNodeTable = <span class="keyword">new</span> Vertice&lt;V&gt;[maxNumVertices];</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">GraphAL</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;<span class="comment">//顶点满了，扩充</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">V <span class="title">getValue</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;<span class="comment">//获得指定顶点的值</span></span><br><span class="line">		<span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= curNumVertices)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> verNodeTable[pos].value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;<span class="comment">//获得(v1,v2)的权值</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices || v2 &lt; <span class="number">0</span> || v2 &gt;= curNumVertices)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		EdgeNode* temp = verNodeTable[v1].adj;</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;anotherVer == v2)<span class="keyword">return</span> temp-&gt;weight;</span><br><span class="line">				<span class="keyword">else</span> temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getVerticePos</span><span class="params">(V ver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (verNodeTable[i].value == ver)<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCurNumVertices</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> curNumVertices; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCurNumEdges</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> curNumEdges; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="type">int</span> v1)</span> </span>&#123;<span class="comment">//找到给定顶点的第一个邻接顶点的位置</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		EdgeNode* temp = verNodeTable[v1].adj;</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> temp-&gt;anotherVer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;<span class="comment">//在以v1为起点的边表中，返回边（v1,v2）的下一条边的邻接顶点</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		EdgeNode* temp = verNodeTable[v1].adj;</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;anotherVer != v2)temp = temp-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (temp != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next != <span class="literal">nullptr</span>)<span class="keyword">return</span> temp-&gt;next-&gt;anotherVer;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">addVertice</span><span class="params">(V vertice)</span> </span>&#123;<span class="comment">//添加结点</span></span><br><span class="line">		<span class="comment">//结点数达到上限，扩容</span></span><br><span class="line">		<span class="keyword">if</span> (curNumVertices == maxNumVertices)<span class="built_in">extend</span>();</span><br><span class="line">		verNodeTable[curNumVertices++].value = vertice;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">double</span> w)</span> </span>&#123;<span class="comment">//添加边(v1,v2),权值为w</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices || v2 &lt; <span class="number">0</span> || v2 &gt;= curNumVertices)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//创建两个边结点：v1到v2和v2到v1</span></span><br><span class="line">		EdgeNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">//将边结点联入v1顶点的边链表</span></span><br><span class="line">		temp = verNodeTable[v1].adj;</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)verNodeTable[v1].adj = <span class="keyword">new</span> <span class="built_in">EdgeNode</span>(v2, w);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (temp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="comment">//这条边已经在边链表中，添加失败</span></span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;anotherVer == v2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			temp-&gt;next = <span class="keyword">new</span> <span class="built_in">EdgeNode</span>(v2, w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//无向图的额外操作：将边结点联入v2顶点的边链表</span></span><br><span class="line">		<span class="keyword">if</span> (isDirected == <span class="literal">false</span>) &#123;</span><br><span class="line">			temp = verNodeTable[v2].adj;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)verNodeTable[v2].adj = <span class="keyword">new</span> <span class="built_in">EdgeNode</span>(v1, w);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (temp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					<span class="comment">//这条边已经在边链表中，添加失败</span></span><br><span class="line">					<span class="keyword">if</span> (temp-&gt;anotherVer == v1)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">					temp = temp-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				temp-&gt;next = <span class="keyword">new</span> <span class="built_in">EdgeNode</span>(v1, w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//记得边数+1</span></span><br><span class="line">		curNumEdges++;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">removeVertice</span><span class="params">(<span class="type">int</span> vPos)</span> </span>&#123;<span class="comment">//删除指定顶点v</span></span><br><span class="line">		<span class="keyword">if</span> (vPos &lt; <span class="number">0</span> || vPos &gt;= curNumVertices)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (curNumVertices == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//只有一个顶点，删除失败</span></span><br><span class="line">		EdgeNode* temp = verNodeTable[vPos].adj;<span class="comment">//遍历边表的指针</span></span><br><span class="line">		EdgeNode* preTem = <span class="literal">nullptr</span>;<span class="comment">//遍历边表的指针的前驱指针</span></span><br><span class="line">		<span class="comment">//把被删顶点的边表删除，并且将每个边关联到的另一个顶点的对应边结点删除</span></span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="comment">//无向图的额外操作：把边关联到的另一个顶点那里的对应边结点删除</span></span><br><span class="line">			<span class="keyword">if</span> (isDirected == <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="type">int</span> v = temp-&gt;anotherVer;</span><br><span class="line">				EdgeNode* p = verNodeTable[v].adj;</span><br><span class="line">				EdgeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">				<span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;anotherVer != vPos) &#123;</span><br><span class="line">					pre = p;</span><br><span class="line">					p = p-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (pre == <span class="literal">nullptr</span>)verNodeTable[v].adj = p-&gt;next;<span class="comment">//删头节点情况</span></span><br><span class="line">				<span class="keyword">else</span> pre-&gt;next = p-&gt;next;<span class="comment">//应该要判断p不为空的，但一定找的到，所以就不判断了</span></span><br><span class="line">				<span class="keyword">delete</span> p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//关联的信息删完后，将待删边表的对应结点删除</span></span><br><span class="line">			preTem = temp;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> preTem;</span><br><span class="line">			curNumEdges--;<span class="comment">//记得边数-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//边表删完后，用最后一个顶点代替被删顶点的位置,同时更新边表</span></span><br><span class="line">		curNumVertices--;<span class="comment">//记得顶点数-1</span></span><br><span class="line">		verNodeTable[vPos].value = verNodeTable[curNumVertices].value;</span><br><span class="line">		verNodeTable[vPos].adj = verNodeTable[curNumVertices].adj;</span><br><span class="line">		<span class="comment">//无向图额外的操作：</span></span><br><span class="line">		<span class="comment">/*找到与最后一个顶点的边关联的另一个顶点，去它那的边表里找到</span></span><br><span class="line"><span class="comment">				对应边结点，将关联地址改为vPos*/</span></span><br><span class="line">		<span class="keyword">if</span> (isDirected == <span class="literal">false</span>) &#123;</span><br><span class="line">			EdgeNode* update = verNodeTable[vPos].adj;</span><br><span class="line">			<span class="keyword">while</span> (update != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="type">int</span> n = update-&gt;anotherVer;</span><br><span class="line">				EdgeNode* q = verNodeTable[n].adj;</span><br><span class="line">				<span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (q-&gt;anotherVer == curNumVertices) &#123;</span><br><span class="line">						q-&gt;anotherVer = vPos;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					q = q-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				update = update-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;<span class="comment">//删除边(v1,v2)</span></span><br><span class="line">		<span class="keyword">if</span> (v1 &lt; <span class="number">0</span> || v1 &gt;= curNumVertices || v2 &lt; <span class="number">0</span> || v2 &gt;= curNumVertices)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		EdgeNode* temp1 = verNodeTable[v1].adj;</span><br><span class="line">		EdgeNode* temp2 = verNodeTable[v2].adj;</span><br><span class="line">		EdgeNode* pre1 = <span class="literal">nullptr</span>;<span class="comment">//给链表删除结点时要记录被删结点的前驱结点</span></span><br><span class="line">		EdgeNode* pre2 = <span class="literal">nullptr</span>;<span class="comment">//给链表删除结点时要记录被删结点的前驱结点</span></span><br><span class="line">		<span class="comment">//边表为空，删除失败</span></span><br><span class="line">		<span class="keyword">if</span> (temp1 == <span class="literal">nullptr</span> || temp2 == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//去v1的边链表里删除边</span></span><br><span class="line">		<span class="keyword">while</span> (temp1 != <span class="literal">nullptr</span> &amp;&amp; temp1-&gt;anotherVer != v2) &#123;</span><br><span class="line">			pre1 = temp1;</span><br><span class="line">			temp1 = temp1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp1 != <span class="literal">nullptr</span>) &#123;<span class="comment">//非空，则找到要删的边</span></span><br><span class="line">			<span class="keyword">if</span> (pre1 == <span class="literal">nullptr</span>)verNodeTable[v1].adj = temp1-&gt;next;<span class="comment">//删头节点的情况</span></span><br><span class="line">			<span class="keyword">else</span> pre1-&gt;next = temp1-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> temp1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到要删的边，删除失败</span></span><br><span class="line">		<span class="comment">//无向图额外的操作：去v2的边链表里删除边</span></span><br><span class="line">		<span class="keyword">if</span> (isDirected == <span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (temp2 != <span class="literal">nullptr</span> &amp;&amp; temp2-&gt;anotherVer != v1) &#123;</span><br><span class="line">				pre2 = temp2;</span><br><span class="line">				temp2 = temp2-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp2 != <span class="literal">nullptr</span>) &#123;<span class="comment">//非空，则找到要删的边</span></span><br><span class="line">				<span class="keyword">if</span> (pre2 == <span class="literal">nullptr</span>)verNodeTable[v2].adj = temp2-&gt;next;<span class="comment">//删头节点的情况</span></span><br><span class="line">				<span class="keyword">else</span> pre2-&gt;next = temp2-&gt;next;</span><br><span class="line">				<span class="keyword">delete</span> temp2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到要删的边，删除失败</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//记得边数-1</span></span><br><span class="line">		curNumEdges--;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;顶点&quot;</span> &lt;&lt; verNodeTable[i].value;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;的关联顶点：&quot;</span>;</span><br><span class="line">			EdgeNode* temp = verNodeTable[i].adj;</span><br><span class="line">			<span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="type">int</span> n = temp-&gt;anotherVer;</span><br><span class="line">				cout &lt;&lt; verNodeTable[n].value &lt;&lt; <span class="string">&quot;(权值&quot;</span> &lt;&lt; temp-&gt;weight &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(V ver)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> vPos = <span class="built_in">getVerticePos</span>(ver);<span class="comment">//起点</span></span><br><span class="line">		<span class="keyword">if</span> (vPos == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span>* flag = <span class="keyword">new</span> <span class="type">int</span>[curNumVertices] &#123;<span class="number">0</span>&#125;;<span class="comment">//记录顶点是否已经遍历过</span></span><br><span class="line">		<span class="built_in">DFS</span>(vPos, flag);</span><br><span class="line">		<span class="comment">//这个图可能是不连通的，还有些顶点没遍历到：以没遍历到的顶点为起点继续遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)<span class="built_in">DFS</span>(i, flag);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(V ver)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> start = <span class="built_in">getVerticePos</span>(ver);<span class="comment">//获得其实顶点的位置</span></span><br><span class="line">		<span class="keyword">if</span> (start == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//flag标记是否遍历过，为了自己调用自己时保存先前记录，因此用static变量</span></span><br><span class="line">		<span class="type">static</span> <span class="type">int</span>* flag = <span class="keyword">new</span> <span class="type">int</span>[curNumVertices] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		Queue&lt;Vertice&lt;V&gt;&gt;s;<span class="comment">//队列存储的是顶点的数据类型</span></span><br><span class="line">		Vertice&lt;V&gt; temp;<span class="comment">//暂存出队顶点</span></span><br><span class="line">		s.<span class="built_in">EnQueue</span>(verNodeTable[start]);<span class="comment">//将起始顶点入队</span></span><br><span class="line">		flag[start] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!s.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">			s.<span class="built_in">DeQueue</span>(temp);</span><br><span class="line">			start = <span class="built_in">getVerticePos</span>(temp.value);<span class="comment">//以出队顶点为起点，向外搜索一层</span></span><br><span class="line">			cout &lt;&lt; temp.value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			EdgeNode* p = temp.adj;</span><br><span class="line">			<span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;<span class="comment">//将所有与出队顶点相邻的顶点（未遍历）入队</span></span><br><span class="line">				<span class="keyword">if</span> (flag[p-&gt;anotherVer] == <span class="number">0</span>) &#123;</span><br><span class="line">					s.<span class="built_in">EnQueue</span>(verNodeTable[p-&gt;anotherVer]);</span><br><span class="line">					flag[p-&gt;anotherVer] = <span class="number">1</span>;<span class="comment">//入队就标记</span></span><br><span class="line">				&#125;</span><br><span class="line">				p = p-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这个图可能是不连通的，还有些顶点没遍历到：以没遍历到的顶点为起点继续遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)<span class="built_in">BFS</span>(<span class="built_in">getValue</span>(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> isDirected;<span class="comment">//false为无向图，true为有向图</span></span><br><span class="line">	Vertice&lt;V&gt;* verNodeTable;<span class="comment">//存放顶点的表</span></span><br><span class="line">	<span class="type">int</span> maxNumVertices;<span class="comment">//最大顶点数</span></span><br><span class="line">	<span class="type">int</span> curNumVertices;<span class="comment">//当前顶点数</span></span><br><span class="line">	<span class="type">int</span> curNumEdges;<span class="comment">//当前边数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> vPos, <span class="type">int</span>* flag)</span> </span>&#123;</span><br><span class="line">		flag[vPos] = <span class="number">1</span>;<span class="comment">//记录遍历过了</span></span><br><span class="line">		cout &lt;&lt; verNodeTable[vPos].value &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出</span></span><br><span class="line">		EdgeNode* temp = verNodeTable[vPos].adj;<span class="comment">//获得该顶点的边表</span></span><br><span class="line">		<span class="comment">//如果边表为空（无邻接顶点），直接返回；否则对每个邻接顶点进行DFS</span></span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[temp-&gt;anotherVer] == <span class="number">0</span>)<span class="built_in">DFS</span>(temp-&gt;anotherVer, flag);</span><br><span class="line">			<span class="keyword">else</span> temp = temp-&gt;next;<span class="comment">//回溯后，继续走本顶点的边表，看看还有没有邻接顶点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p><strong>网上大多数代码都默认图是连通的，也就是从任意顶点开始都能遍历完图中所有顶点。但以下我写的代码，图可能是不连通的，因此在算法最后会检查是否有没遍历到的顶点，如果有，就已没遍历的顶点为起点继续遍历</strong></p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>深度优先搜索：一条路走到黑，没路了再返回，返回后每个回溯点都看看有没有其他还没走的路，如果有，重复上述操作</p>
<p>关键在回溯$\Rightarrow$递归好写</p>
<p>代码<br>承接上面存储结构的代码</p>
<ul>
<li>DFS邻接矩阵<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(V ver)</span> </span>&#123;<span class="comment">//从给定的顶点ver开始搜索</span></span><br><span class="line">		<span class="type">int</span>* flag = <span class="keyword">new</span> <span class="type">int</span>[curNumVertices] &#123;<span class="number">0</span>&#125;;<span class="comment">//记录顶点是否已经遍历过</span></span><br><span class="line">		<span class="type">int</span> pos = <span class="built_in">getVerPos</span>(ver);<span class="comment">//起点</span></span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(pos, flag);</span><br><span class="line">		<span class="comment">//这个图可能是不连通的，还有些顶点没遍历到：以没遍历到的顶点为起点继续遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)<span class="built_in">DFS</span>(i, flag);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span>*flag)</span> </span>&#123;</span><br><span class="line">		flag[pos] = <span class="number">1</span>;<span class="comment">//记录这个顶点遍历到了</span></span><br><span class="line">		cout &lt;&lt;<span class="built_in">getValue</span>(pos)&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出</span></span><br><span class="line">		<span class="comment">//如果这个顶点有邻接顶点，就继续DFS；否则就返回</span></span><br><span class="line">		<span class="type">int</span> p = <span class="built_in">getFirstNeighbor</span>(pos);</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//对当下顶点的每个邻接顶点进行DFS</span></span><br><span class="line">			<span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flag[p] == <span class="number">0</span>)<span class="built_in">DFS</span>(p, flag);</span><br><span class="line">				p = <span class="built_in">getNextNeighbor</span>(pos, p);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>DFS邻接表<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(V ver)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> vPos = <span class="built_in">getVerticePos</span>(ver);<span class="comment">//起点</span></span><br><span class="line">		<span class="keyword">if</span> (vPos == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span>* flag = <span class="keyword">new</span> <span class="type">int</span>[curNumVertices] &#123;<span class="number">0</span>&#125;;<span class="comment">//记录顶点是否已经遍历过</span></span><br><span class="line">		<span class="built_in">DFS</span>(vPos, flag);</span><br><span class="line">		<span class="comment">//这个图可能是不连通的，还有些顶点没遍历到：以没遍历到的顶点为起点继续遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)<span class="built_in">DFS</span>(i, flag);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> vPos, <span class="type">int</span>* flag)</span> </span>&#123;</span><br><span class="line">		flag[vPos] = <span class="number">1</span>;<span class="comment">//记录遍历过了</span></span><br><span class="line">		cout &lt;&lt; verNodeTable[vPos].value &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出</span></span><br><span class="line">		EdgeNode* temp = verNodeTable[vPos].adj;<span class="comment">//获得该顶点的边表</span></span><br><span class="line">		<span class="comment">//如果边表为空（无邻接顶点），直接返回；否则对每个邻接顶点进行DFS</span></span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[temp-&gt;anotherVer] == <span class="number">0</span>)<span class="built_in">DFS</span>(temp-&gt;anotherVer, flag);</span><br><span class="line">			<span class="keyword">else</span> temp = temp-&gt;next;<span class="comment">//回溯后，继续走本顶点的边表，看看还有没有邻接顶点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>广度优先搜索：每次，每个顶点都只向外扩散一层</p>
<p>关键在队列实现</p>
<p>代码<br>承接上面存储结构的代码</p>
<ul>
<li>BFS邻接矩阵<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(V ver)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> start = <span class="built_in">getVerPos</span>(ver);<span class="comment">//找位置，没有该顶点就直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (start == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		V val;<span class="comment">//用来暂存出队顶点</span></span><br><span class="line">		Queue&lt;V&gt; s;<span class="comment">//搜索时用到的队列</span></span><br><span class="line">		<span class="comment">//flag标记是否遍历过，为了自己调用自己时保存先前记录，因此用static变量</span></span><br><span class="line">		<span class="type">static</span> <span class="type">int</span>* flag = <span class="keyword">new</span> <span class="type">int</span>[curNumVertices] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		s.<span class="built_in">EnQueue</span>(ver);<span class="comment">//先将起点入队</span></span><br><span class="line">		flag[start] = <span class="number">1</span>;<span class="comment">//标记起点已遍历过</span></span><br><span class="line">		<span class="keyword">while</span> (!s.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">			s.<span class="built_in">DeQueue</span>(val);</span><br><span class="line">			start = <span class="built_in">getVerPos</span>(val);<span class="comment">//以出队顶点为起点，向外搜索一层</span></span><br><span class="line">			cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="type">int</span> p = <span class="built_in">getFirstNeighbor</span>(start);</span><br><span class="line">			<span class="comment">//将所有与出队顶点相邻的顶点（未遍历）入队</span></span><br><span class="line">			<span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flag[p] == <span class="number">0</span>) &#123;</span><br><span class="line">					s.<span class="built_in">EnQueue</span>(verticesList[p]);</span><br><span class="line">					flag[p] = <span class="number">1</span>;<span class="comment">//入队时就标记</span></span><br><span class="line">				&#125;</span><br><span class="line">				p = <span class="built_in">getNextNeighbor</span>(start, p);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这个图可能是不连通的，还有些顶点没遍历到：以没遍历到的顶点为起点继续遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)<span class="built_in">BFS</span>(<span class="built_in">getValue</span>(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>BFS邻接表<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(V ver)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> start = <span class="built_in">getVerticePos</span>(ver);<span class="comment">//获得其实顶点的位置</span></span><br><span class="line">		<span class="keyword">if</span> (start == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//flag标记是否遍历过，为了自己调用自己时保存先前记录，因此用static变量</span></span><br><span class="line">		<span class="type">static</span> <span class="type">int</span>* flag = <span class="keyword">new</span> <span class="type">int</span>[curNumVertices] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		Queue&lt;Vertice&lt;V&gt;&gt;s;<span class="comment">//队列存储的是顶点的数据类型</span></span><br><span class="line">		Vertice&lt;V&gt; temp;<span class="comment">//暂存出队顶点</span></span><br><span class="line">		s.<span class="built_in">EnQueue</span>(verNodeTable[start]);<span class="comment">//将起始顶点入队</span></span><br><span class="line">		flag[start] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!s.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">			s.<span class="built_in">DeQueue</span>(temp);</span><br><span class="line">			start = <span class="built_in">getVerticePos</span>(temp.value);<span class="comment">//以出队顶点为起点，向外搜索一层</span></span><br><span class="line">			cout &lt;&lt; temp.value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			EdgeNode* p = temp.adj;</span><br><span class="line">			<span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;<span class="comment">//将所有与出队顶点相邻的顶点（未遍历）入队</span></span><br><span class="line">				<span class="keyword">if</span> (flag[p-&gt;anotherVer] == <span class="number">0</span>) &#123;</span><br><span class="line">					s.<span class="built_in">EnQueue</span>(verNodeTable[p-&gt;anotherVer]);</span><br><span class="line">					flag[p-&gt;anotherVer] = <span class="number">1</span>;<span class="comment">//入队就标记</span></span><br><span class="line">				&#125;</span><br><span class="line">				p = p-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这个图可能是不连通的，还有些顶点没遍历到：以没遍历到的顶点为起点继续遍历</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curNumVertices; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)<span class="built_in">BFS</span>(<span class="built_in">getValue</span>(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p><strong>生成树</strong><br>如果<strong>连通图</strong>的一个子图是一棵包含所有顶点的树，则该子图称为G的生成树(SpanningTree)。换句话说，生成树是由图中所有顶点构成的极小连通子图。</p>
<blockquote>
<p>Informally, a minimum spanning tree of an undirected graph G is a tree formed from graph edges that connects all the vertices of G at lowest total cost. A minimum spanning tree exists if and only if G is connected. </p>
</blockquote>
<p>满足性质：边数&#x3D;顶点数-1</p>
<p>生成树并不唯一，只要能连通所有顶点而又不产生回路的任何子图都是G的生成树（DFS生成树，BFS生成树，Kruskal最小生成树树，Prim最小生成树…）<br><strong>最小生成树</strong><br>对于无向连通图来说，权值最小的生成树被成为最小生成树。<br><strong>不同算法的作用对象</strong><br>Kruskal和Prim算法适用求<em>无向连通图</em>的最小生成树<br>Chu-Liu&#x2F;Edmonds算法适用于求<em>有向连通图</em>的最小生成树</p>
<p><strong>先将最小生成树的边界点定义出来</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MSTEdgeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> v1;</span><br><span class="line">	<span class="type">int</span> v2;<span class="comment">//两个端点的位置</span></span><br><span class="line">	<span class="type">double</span> weight;<span class="comment">//边的权值</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &gt;(MSTEdgeNode&amp; s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;weight &gt; s.weight)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(MSTEdgeNode&amp; s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;weight &lt; s.weight)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &gt;=(MSTEdgeNode&amp; s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;weight &gt;= s.weight)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;=(MSTEdgeNode&amp; s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;weight &lt;= s.weight)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>为了方便，默认传进来的图都是连通图</p>
<h3 id="Kruskal算法（避圈法）"><a href="#Kruskal算法（避圈法）" class="headerlink" title="Kruskal算法（避圈法）"></a>Kruskal算法（避圈法）</h3><p><strong>贪心策略</strong><br>考察每一条边，每次拿出权值最小的边，若两端点在同一连通分量（加上这个边，就会构成一个回路），则舍弃；不在同一连通分量，则加入生成树</p>
<p><strong>分析用什么结构</strong><br>显然，用一个最小堆可以解决每次都拿权值最小边的问题<br>考察两端点是否在同一连通分量里，实际上就是一个等价类问题，可以用到并查集</p>
<blockquote>
<p>Formally, Kruskal’s algorithm maintains a forest—a collection of trees. Initially, there are |V| single-node trees. Adding an edge merges two trees into one. When the algorithm terminates, there is only one tree, and this is the minimum spanning tree. </p>
</blockquote>
<p><strong>代码实现</strong><br>最小堆，并查集的代码都是用我以前自己实现的代码<br><em>注意：我的<code>GraphAM</code>没有重写拷贝构造函数，如果只是传参类对象，副本的指针变量是直接赋值，函数退出后指针会被delete一次，main函数结束后原本的对象也要析构，那指针就会被delete两次，触发断点。所以这里为了简单（懒得重写复制构造函数），直接传引用</em></p>
<p>邻接矩阵和邻接表的代码一模一样（这两个结构一样功能的函数，名字我都起的一样），只是在它们各自结构里相同功能的函数的实现不一样而已</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="comment">//参数换成(GraphAL&lt;V&gt; &amp;graph)就是邻接表的代码</span></span><br><span class="line"><span class="function">vector&lt;MSTEdgeNode&gt; <span class="title">Kruskal</span><span class="params">(GraphAM&lt;V, E&gt; &amp;graph)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> edgeNum = graph.<span class="built_in">getCurNumEdges</span>();<span class="comment">//获取图的边数</span></span><br><span class="line">	<span class="type">int</span> verNum = graph.<span class="built_in">getCurNumVertices</span>();<span class="comment">//获取边的顶点数</span></span><br><span class="line">	vector&lt;MSTEdgeNode&gt; mst;<span class="comment">//数组存储最小生成树的边</span></span><br><span class="line">	MinHeap&lt;MSTEdgeNode&gt;* hp = <span class="keyword">new</span> MinHeap&lt;MSTEdgeNode&gt;[edgeNum];<span class="comment">//最小堆存储边结点</span></span><br><span class="line">	<span class="function">DisjSets <span class="title">ds</span><span class="params">(verNum)</span></span>;<span class="comment">//并查集存放顶点：第i个顶点的在树中的父顶点是ds[i]</span></span><br><span class="line">	MSTEdgeNode minEdge;<span class="comment">//暂存每次取出来的最小边</span></span><br><span class="line">	<span class="comment">//先将图中所有边结点入最小堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; verNum; i++) &#123;</span><br><span class="line">		<span class="type">int</span> v = graph.<span class="built_in">getFirstNeighbor</span>(i);</span><br><span class="line">		<span class="keyword">while</span> (v != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="type">double</span> w = graph.<span class="built_in">getWeight</span>(i, v);</span><br><span class="line">			MSTEdgeNode temp&#123; i,v,w &#125;;</span><br><span class="line">			hp-&gt;<span class="built_in">EnMinHeap</span>(temp);</span><br><span class="line">			v = graph.<span class="built_in">getNextNeighbor</span>(i, v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构建最小生成树，中止条件：边数=顶点数-1</span></span><br><span class="line">	<span class="keyword">while</span> (mst.<span class="built_in">size</span>() &lt;verNum<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="comment">//MSTEdgeNode minEdge;</span></span><br><span class="line">		hp-&gt;<span class="built_in">DeMinHeap</span>(minEdge);</span><br><span class="line">		<span class="type">int</span> set1 = ds.<span class="built_in">find</span>(minEdge.v1);<span class="comment">//获取v1所在的连通分量</span></span><br><span class="line">		<span class="type">int</span> set2 = ds.<span class="built_in">find</span>(minEdge.v2);<span class="comment">//获取v2所在的连通分量</span></span><br><span class="line">		<span class="keyword">if</span> (set1 != set2) &#123;<span class="comment">//如果不在一个连通分量，就加入最小生成树</span></span><br><span class="line">			mst.<span class="built_in">push_back</span>(minEdge);</span><br><span class="line">			ds.<span class="built_in">unionSets</span>(set1, set2);<span class="comment">//将这v1，v2所在的连通分量合并</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mst;<span class="comment">//返回构建好的最小生成树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p><strong>贪心策略</strong><br>每次选出一个端点在生成树中，另一个端点不在生成树中的权值最小的边加入生成树</p>
<p><strong>代码实现</strong><br>呃呃网上的代码看得有点晕，我这个好像写的和那些代码长得不太一样（但我觉得思路是一样的），但结果是对的</p>
<p>邻接矩阵和邻接表的代码一模一样（这两个结构一样功能的函数，名字我都起的一样），只是在它们各自结构里相同功能的函数的实现不一样而已</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="comment">//参数换成GraphAL&lt;V&gt;&amp; graph就是邻接表的代码</span></span><br><span class="line"><span class="function">vector&lt;MSTEdgeNode&gt; <span class="title">Prim</span><span class="params">(GraphAM&lt;V, E&gt;&amp; graph,V ver)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> curAdd = graph.<span class="built_in">getVerPos</span>(ver);<span class="comment">//记录刚加入生成树的顶点的位置</span></span><br><span class="line">	<span class="type">int</span> edgeNum = graph.<span class="built_in">getCurNumEdges</span>();<span class="comment">//获取图的边数</span></span><br><span class="line">	<span class="type">int</span> verNum = graph.<span class="built_in">getCurNumVertices</span>();<span class="comment">//获取边的顶点数</span></span><br><span class="line">	<span class="type">int</span>* isInMST = <span class="keyword">new</span> <span class="type">int</span>[verNum]&#123;<span class="number">0</span>&#125;;<span class="comment">//记录对应顶点是否在生成树里</span></span><br><span class="line">	MinHeap&lt;MSTEdgeNode&gt;* hp = <span class="keyword">new</span> MinHeap&lt;MSTEdgeNode&gt;[edgeNum];<span class="comment">//最小堆存储边结点</span></span><br><span class="line">	vector&lt;MSTEdgeNode&gt; mst;<span class="comment">//数组存储最小生成树的边</span></span><br><span class="line">	MSTEdgeNode minEdge;<span class="comment">//暂存每次取出来的最小边</span></span><br><span class="line">	isInMST[curAdd] = <span class="number">1</span>;<span class="comment">//先将起始点记录为在生成树中</span></span><br><span class="line">	<span class="comment">//开始操作</span></span><br><span class="line">	<span class="keyword">while</span> (mst.<span class="built_in">size</span>() &lt; verNum - <span class="number">1</span>) &#123;<span class="comment">//中止条件：边数=顶点数-1</span></span><br><span class="line">		<span class="comment">//将与【新加入生成树的顶点】相连的所有边加入最小堆</span></span><br><span class="line">		<span class="type">int</span> j = graph.<span class="built_in">getFirstNeighbor</span>(curAdd);</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>) &#123;</span><br><span class="line">			MSTEdgeNode edge&#123; curAdd,j,graph.<span class="built_in">getWeight</span>(curAdd,j) &#125;;</span><br><span class="line">			hp-&gt;<span class="built_in">EnMinHeap</span>(edge);</span><br><span class="line">			j = graph.<span class="built_in">getNextNeighbor</span>(curAdd, j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取一个顶点在生成树，另一个顶点不在生成树的最小边</span></span><br><span class="line">		hp-&gt;<span class="built_in">DeMinHeap</span>(minEdge);</span><br><span class="line">		<span class="keyword">while</span> (isInMST[minEdge.v2] == <span class="number">1</span>) hp-&gt;<span class="built_in">DeMinHeap</span>(minEdge);</span><br><span class="line">		<span class="comment">//将这个最小边加入生成树</span></span><br><span class="line">		mst.<span class="built_in">push_back</span>(minEdge);</span><br><span class="line">		curAdd = minEdge.v2;<span class="comment">//新加入的结点就是最小边的v2</span></span><br><span class="line">		isInMST[curAdd] = <span class="number">1</span>;<span class="comment">//标记在生成树里</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> mst;<span class="comment">//返回构建好的最小生成树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="Kruskal和Prim算法对比分析"><a href="#Kruskal和Prim算法对比分析" class="headerlink" title="Kruskal和Prim算法对比分析"></a>Kruskal和Prim算法对比分析</h3><p><strong>直观上的感觉</strong><br>Kruskal每次都选一个不构成回路的最小边出来，因此这些边是零散分布的，在最终形成一个最小生成树之前，是一个个最小生成树森林</p>
<p>Prim每次都是选出和生成树相连的边里最小的那个，因此自始至终都是连通的</p>
<p><strong>性能分析（性能推导看书）</strong><br>一般情况下Kruskal算法更快，Prim算法适合稠密矩阵（边数远大于顶点数）</p>
<blockquote>
<p>Use Prim’s algorithm when you have a graph with lots of edges.For a graph with V vertices E edges, Kruskal’s algorithm runs in O(E log V) time and Prim’s algorithm can run in O(E + V log V) amortized time, if you use a Fibonacci Heap.<br>Prim’s algorithm is significantly faster in the limit when you’ve got a really dense graph with many more edges than vertices. Kruskal performs better in typical situations (sparse graphs) because it uses simpler data structures.</p>
</blockquote>
<h3 id="Chu-Liu-x2F-Edmonds算法"><a href="#Chu-Liu-x2F-Edmonds算法" class="headerlink" title="Chu-Liu&#x2F;Edmonds算法"></a>Chu-Liu&#x2F;Edmonds算法</h3><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="最短路径问题的共性思路"><a href="#最短路径问题的共性思路" class="headerlink" title="最短路径问题的共性思路"></a>最短路径问题的共性思路</h3><p><strong>带权有向图和带权无向图都适用，有向图的实际应用意义更大</strong></p>
<p><strong>最短路径的子路径也是最短路径</strong><br>规定p&#x3D;&lt;v<del>0</del>,v<del>1</del>,…v<del>k</del>&gt;是v<del>0</del>到v<del>k</del>的最短路径，对于任意0&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;k,s&#x3D;&lt;v<del>i</del>,v<del>i+1</del>,…v<del>j</del>&gt;是p的一条子路径，则s是v<del>i</del>到v<del>j</del>的最短路径<br>这说明最短路径问题有<em>最优子结构</em></p>
<blockquote>
<p>Recall that optimal substructure is one of the key indicators that dynamic programming and the greedy method might apply. Dijkstra’s algorithm is a greedy algorithm, and the FloydWarshall algorithm, which finds shortest paths between all pairs of vertices is a dynamic-programming algorithm.</p>
</blockquote>
<p><strong>如果图有负权值圈，最短路径无解</strong><br>当一个图含负权值边时，就可能出现负权值圈，这个时候最短路径就很难去定义（一直绕着那个负全圈走，路径长度到最后就变成了负无穷），最短路径问题无解</p>
<p><strong>最短路径必然不含圈</strong><br>图的任意一条最短路径既不能包含负权回路，也不会包含正权回路，因此它<strong>最多包含|v|-1条边</strong>（这在Bellman-Ford算法里十分关键）<br>不含负值圈，正值圈解释</p>
<blockquote>
<p>Can a shortest path contain a cycle? As we have just seen, it cannot contain a negative-weight cycle. Nor can it contain a positive-weight cycle, since removing the cycle from the path produces a path with the same source and destination vertices and a lower path weight.</p>
</blockquote>
<p>不含0权值圈解释</p>
<blockquote>
<p>We can remove a 0-weight cycle from any path to produce another path whose weight is the same. Thus, if there is a shortest path from a source vertex s to a destination vertex that contains a 0-weight cycle, then there is another shortest path from s to without this cycle.</p>
</blockquote>
<p><strong>保存路径</strong><br>对于每个顶点，都只需记录最短路径中本顶点的前驱顶点</p>
<p><strong>松弛技术Relaxation</strong><br>松弛边(u,v)的过程:源点s到v的距离如果能在经过u的情况下缩短，则更新路径长度和路径前驱<br>换句话说。就是用现在的最短路径更新其他的路径</p>
<blockquote>
<p>Relaxation is the only means by which shortestpath estimates and predecessors change. </p>
</blockquote>
<p>不同算法的主要区别就在于松弛的次数和时机</p>
<blockquote>
<p>The algorithms in this chapter differ in how many times they relax each edge and the order in which they relax edges Dijkstra’s algorithm and the shortest-paths algorithm for directed acyclic graphs relax each edge exactly once. The Bellman-Ford algorithm relaxes each edge |V|-1 times.</p>
</blockquote>
<h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><p><strong>不带权值的单源最短路径</strong></p>
<p><strong>任意权值的单源最短路径——Bellman-Ford算法</strong></p>
<ul>
<li>运用最短路必然无环的性质<br>假设有n个顶点，那么最短路的边最多n-1条，此时如果再加一条边，松弛操作仍成立，就说明有负权值圈，最短路问题无解。</li>
<li>动态规划<br>在经过不超过k条边的条件下，计算源点到i的最短路<br>Bellman-Ford(k,i)&#x3D;min{Bellman-Ford(k-1,i),Bellman-Ford(k-1,j)+weight(j,i)}<br>同理<br>$$path(k,i)&#x3D;\begin{cases}<br>  path(k-1,i) &amp; dist[i]&lt;dist[j]+weight(j,i)\<br>  path(k-1,j) &amp; dist[i]&gt;dist[j]+weight(j,i)\<br>\end{cases}$$</li>
<li>代码<br>k对应动态规划的阶段，因此在最外层循环<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BellmanFord</span><span class="params">(GraphAM&lt;V, E&gt;&amp; graph, V ver, <span class="type">double</span> dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> vPos = graph.<span class="built_in">getVerPos</span>(ver);<span class="comment">//获得源点位置</span></span><br><span class="line">	<span class="type">int</span> verNum = graph.<span class="built_in">getCurNumVertices</span>();<span class="comment">//获得总结点数</span></span><br><span class="line">	<span class="comment">//初始化操作</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; verNum; k++) &#123;</span><br><span class="line">		dist[k] = (k == vPos) ? <span class="number">0</span> : INF;</span><br><span class="line">		path[k] = (k == vPos) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; verNum; k++) &#123;<span class="comment">//v经过不多于k条边到达终点的最短距离</span></span><br><span class="line">		<span class="comment">//对每条边松弛</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; verNum; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i != vPos) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; verNum; j++) &#123;</span><br><span class="line">					<span class="type">double</span> w = graph.<span class="built_in">getWeight</span>(j, i);</span><br><span class="line">					<span class="keyword">if</span> (dist[i] &gt; dist[j] + w) &#123;</span><br><span class="line">						dist[i] = dist[j] + w;</span><br><span class="line">						path[i] = j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//再对所有边判断，如果还能松弛，说明有负权值圈，无解</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; verNum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != vPos) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; verNum; j++) &#123;</span><br><span class="line">				<span class="type">double</span> w = graph.<span class="built_in">getWeight</span>(j, i);</span><br><span class="line">				<span class="keyword">if</span> (dist[i] &gt; dist[j] + w) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>对判断是否有负权值圈进行优化<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>
<strong>优先级队列优化Bellman-Ford算法——SPFA算法</strong></li>
</ul>
<p><strong>非负权值的单源最短路径——Dijkstra算法</strong></p>
<ul>
<li><p>辅助数组的含义<br>dist[i]：源点s到顶点i的最短距离<br>path[i]：源点s到顶点i的最短路径中，i的前驱顶点<br>集合S：存放最短路径已经确定的顶点<br>集合Q：顶点全集V-S，存放最短路径未确定的顶点<br>book[i]：标记顶点i的最短路径是否已经确定（true，顶点在集合S中；false，顶点在集合Q中）</p>
</li>
<li><p>贪心策略<br>每一轮，都把一个到源点s距离最短（dist[i]最小）且在集合Q中的顶点v取出，放入集合S（标记book[i]&#x3D;true），然后经由v，对集合Q中的顶点进行松弛操作。整个算法的中止条件就是Q为空集，也就是S&#x3D;全集V，所有顶点的最短路径都被确定。</p>
</li>
<li><p>Dijkstra算法运用到了BFS算法和Prim算法的思想</p>
<blockquote>
<p>It is like breadth-first search in that set S corresponds to the set of black vertices in a breadth-first search; just as vertices in S have their final shortest-path weights, so do black vertices in a breadth-first search have their correct breadth-first distances.<br>Dijkstra’s algorithm is like Prim’s algorithm in that both algorithms use a min-priority queue to find the “lightest” vertex outside a given set (the set S in Dijkstra’s<br>algorithm and the tree being grown in Prim’s algorithm), add this vertex into the set, and adjust the weights of the remaining vertices outside the set accordingly.</p>
</blockquote>
</li>
<li><p>代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> V, <span class="keyword">class</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Disjkstra</span><span class="params">(GraphAM&lt;V, E&gt;&amp; graph, V ver, <span class="type">double</span> dist[], <span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> vPos = graph.<span class="built_in">getVerPos</span>(ver);<span class="comment">//获得源点位置</span></span><br><span class="line">	<span class="type">int</span> verNum = graph.<span class="built_in">getCurNumVertices</span>();<span class="comment">//获得总结点数</span></span><br><span class="line">	<span class="type">bool</span>* book = <span class="keyword">new</span> <span class="type">bool</span>[verNum];<span class="comment">//标记顶点最短路径是否已经确定</span></span><br><span class="line">	<span class="comment">//初始化操作</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; verNum; k++) &#123;</span><br><span class="line">		dist[k] = graph.<span class="built_in">getWeight</span>(vPos, k);</span><br><span class="line">		<span class="comment">//与源点相邻，初始化路径前驱就是源点，否则置为-1</span></span><br><span class="line">		<span class="keyword">if</span> (k!=vPos&amp;&amp;dist[k] &lt; INF)path[k] = vPos;</span><br><span class="line">		<span class="keyword">else</span> path[k] = <span class="number">-1</span>;</span><br><span class="line">		book[k] = <span class="literal">false</span>;<span class="comment">//一开是，所有顶点都在集合Q</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> newAdd = vPos;<span class="comment">//将源点加入集合S</span></span><br><span class="line">	book[vPos] = <span class="literal">true</span>;<span class="comment">//源点的最短路径标记为已知</span></span><br><span class="line">	dist[vPos] = <span class="number">0</span>;<span class="comment">//源点到自己的距离规定为1</span></span><br><span class="line">	<span class="comment">//正式开始算法操作</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; verNum; i++) &#123;</span><br><span class="line">		<span class="comment">//找出与源点距离最短且在集合Q中的顶点</span></span><br><span class="line">		<span class="type">int</span> min = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; verNum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (book[j] == <span class="literal">false</span> &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">				newAdd = j;</span><br><span class="line">				min = dist[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		book[newAdd] = <span class="literal">true</span>;<span class="comment">//将这一顶点放入集合S</span></span><br><span class="line">		<span class="comment">//经由这个新加入集合S的顶点，对集合Q中的顶点进行松弛操作</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; verNum; k++) &#123;</span><br><span class="line">			<span class="type">double</span> w = graph.<span class="built_in">getWeight</span>(newAdd, k);</span><br><span class="line">			<span class="keyword">if</span> (book[k] == <span class="literal">false</span> &amp;&amp; dist[k] &gt; dist[newAdd] + w) &#123;</span><br><span class="line">				dist[k] = dist[newAdd] + w;</span><br><span class="line">				path[k] = newAdd;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>搞不懂为什么要有book，我这样也能啊？？</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> V,<span class="keyword">class</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Disjkstra</span><span class="params">(GraphAM&lt;V,E&gt;&amp;graph,V ver,<span class="type">double</span> dist[],<span class="type">int</span> path[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> vPos = graph.<span class="built_in">getVerPos</span>(ver);</span><br><span class="line">	<span class="type">int</span> verNum = graph.<span class="built_in">getCurNumVertices</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; verNum; k++) &#123;</span><br><span class="line">		dist[k] = graph.<span class="built_in">getWeight</span>(vPos, k);</span><br><span class="line">		<span class="keyword">if</span> (dist[k] &lt; INF)path[k] = vPos;</span><br><span class="line">		<span class="keyword">else</span> path[k] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; verNum; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; verNum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dist[i] &gt; dist[j] + graph.<span class="built_in">getWeight</span>(j, i)) &#123;</span><br><span class="line">				dist[i] = dist[j] + graph.<span class="built_in">getWeight</span>(j, i);</span><br><span class="line">				path[i] = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>用优先级队列优化</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="多源最短路径——Floyd算法"><a href="#多源最短路径——Floyd算法" class="headerlink" title="多源最短路径——Floyd算法"></a>多源最短路径——Floyd算法</h3><p><strong>动态规划</strong><br>用dist[i][j]来存放i到j的最短距离，用path[i][j]来存放i到j最短路径中j的前驱顶点<br>策略是：<br>在经过编号不超过k的顶点的条件下，探究i到j的最短路。<br>Floyd(k,i,j)&#x3D;min{Floyd(k-1,i,j),Floyd(k-1,i,k)+Floyd(k-1,k,j)}<br>同理<br>$$path[i][j]&#x3D;\begin{cases}<br>    path[i][j] &amp; dist[i][j]&lt;dist[i][k]+dist[k][j]\<br>    path[k][j] &amp; dist[i][j]&gt;dist[i][k]+dist[k][j]\<br>\end{cases}$$<br><strong>代码</strong><br>注意：k对应动态规划的阶段，因此放在最外层循环</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(GraphAM&lt;V, E&gt;&amp; graph, <span class="type">double</span> **dist, <span class="type">int</span> **path)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> verNum = graph.<span class="built_in">getCurNumVertices</span>();<span class="comment">//获得总结点数</span></span><br><span class="line">	<span class="comment">//初始化操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;verNum;i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; verNum; j++) &#123;</span><br><span class="line">			dist[i][j] = graph.<span class="built_in">getWeight</span>(i, j);</span><br><span class="line">			<span class="keyword">if</span> (dist[i][j] == INF||i==j)path[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> path[i][j] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;verNum;k++)<span class="comment">//动态规划的阶段</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;verNum;i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; verNum; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (dist[i][j] &gt; dist[i][k] + dist[k][j]) &#123;</span><br><span class="line">					dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">					path[i][j] = path[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="Topological-Sort拓扑排序"><a href="#Topological-Sort拓扑排序" class="headerlink" title="Topological Sort拓扑排序"></a>Topological Sort拓扑排序</h2><p><strong>是啥玩意</strong><br>把有向无环图中各顶点间的前驱，后继关系用线性顺序表现出来</p>
<blockquote>
<p>A topological sort is an ordering of vertices in a directed acyclic graph, such that if there is a path from vi to vj, then vj appears after vi in the ordering.<br>We can view a topological sort of a graph as an ordering of its vertices along a horizontal line so that all directed edges go from left to right.</p>
</blockquote>
<p><strong>必须是在有向无环图里才成立</strong><br>在无向图中或v<del>i</del>和v<del>j</del>构成环，那它们都是既为彼此的前驱也为彼此的后继，这样就排不了序了</p>
<p><strong>算法描述</strong><br>找到一个没有直接前驱（入度&#x3D;0）的顶点v，输出v，然后删除v顶点和v的所有边，重复上述操作。<br>算法结束后（没有入度&#x3D;0的顶点），如果还有顶点剩余，说明有向图有环，不满足要求；否则拓扑排序成功。</p>
<p><strong>优化代码</strong><br>邻接矩阵和邻接表的代码一样，只是传参不一样</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传GraphAM&lt;V,E&gt;就是邻接矩阵的代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSortAL</span><span class="params">(GraphAL&lt;V&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> verNum = graph.<span class="built_in">getCurNumVertices</span>();<span class="comment">//获得顶点个数</span></span><br><span class="line">	Queue&lt;V&gt; q;<span class="comment">//用队列存放入度=0的顶点</span></span><br><span class="line">	<span class="type">int</span>* inDegree = <span class="keyword">new</span> <span class="type">int</span>[verNum]&#123;<span class="number">0</span>&#125;;<span class="comment">//记录各顶点的入度</span></span><br><span class="line">	<span class="type">int</span> amount = <span class="number">0</span>;<span class="comment">//记录输出了几个顶点</span></span><br><span class="line">	V deVer;<span class="comment">//记录出队的顶点</span></span><br><span class="line">	<span class="type">int</span> v1, v2;<span class="comment">//用于添加边(v1,v2)</span></span><br><span class="line">	<span class="type">double</span> w;<span class="comment">//用于给边赋权重</span></span><br><span class="line">	<span class="comment">//给图初始化：添加有向边</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;添加边（v1,v2）:&quot;</span>;</span><br><span class="line">	cin &gt;&gt; v1 &gt;&gt; v2&gt;&gt;w;</span><br><span class="line">	<span class="keyword">while</span> (v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt; verNum &amp;&amp; v2 &gt;= <span class="number">0</span> &amp;&amp; v2 &lt; verNum) &#123;</span><br><span class="line">		graph.<span class="built_in">addEdge</span>(v1, v2, w);</span><br><span class="line">		inDegree[v2]++;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;添加边（v1,v2）:&quot;</span>;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将所有入度=0的顶点入队</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; verNum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)q.<span class="built_in">EnQueue</span>(graph.<span class="built_in">getValue</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//顶点出队并输出，然后更新与它相邻顶点的入度数，看要不要入队</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">		q.<span class="built_in">DeQueue</span>(deVer);</span><br><span class="line">		cout &lt;&lt; deVer &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		amount++;<span class="comment">//出队的顶点数+1</span></span><br><span class="line">		<span class="type">int</span> dePos = graph.<span class="built_in">getVerticePos</span>(deVer);<span class="comment">//获得出队顶点的位置</span></span><br><span class="line">		<span class="type">int</span> v = graph.<span class="built_in">getFirstNeighbor</span>(dePos);<span class="comment">//找到出队顶点的第一个邻接顶点</span></span><br><span class="line">		<span class="keyword">while</span> (v != <span class="number">-1</span>) &#123;<span class="comment">//更新出队顶点的每个邻接顶点的入度数，若=0，则入队</span></span><br><span class="line">			<span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>)q.<span class="built_in">EnQueue</span>(graph.<span class="built_in">getValue</span>(v));</span><br><span class="line">			v = graph.<span class="built_in">getNextNeighbor</span>(dePos, v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//算法结束后，有顶点没输出，说明有环，拓扑排序失败</span></span><br><span class="line">	<span class="keyword">if</span> (amount != verNum)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="AOV网络"><a href="#AOV网络" class="headerlink" title="AOV网络"></a>AOV网络</h2><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/122375531" >https://zhuanlan.zhihu.com/p/122375531 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Graph</li>
        <li>Post author：萧</li>
        <li>Create time：2023-01-20 13:28:48</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/01/20/数据结构笔记/Graph/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E5%9B%BE/">#图</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Recursive/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Recursive</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/Sort/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Sort</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div style="font-size: 1.3rem;margin-top: 0; margin-bottom: 0.8rem; transition-duration: 0.1s;"><i class="fa-solid fa-list"></i> <strong>Contents</strong></div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%98%E6%B2%A1%E6%83%B3%E5%A5%BD%E5%86%99%E4%BB%80%E4%B9%88"><span class="nav-text">还没想好写什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-text">十字链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-text">邻接多重表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-text">性能比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS"><span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS"><span class="nav-text">BFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-text">连通分量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE"><span class="nav-text">前置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95%EF%BC%88%E9%81%BF%E5%9C%88%E6%B3%95%EF%BC%89"><span class="nav-text">Kruskal算法（避圈法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="nav-text">Prim算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal%E5%92%8CPrim%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="nav-text">Kruskal和Prim算法对比分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chu-Liu-x2F-Edmonds%E7%AE%97%E6%B3%95"><span class="nav-text">Chu-Liu&#x2F;Edmonds算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B1%E6%80%A7%E6%80%9D%E8%B7%AF"><span class="nav-text">最短路径问题的共性思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">单源最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94Floyd%E7%AE%97%E6%B3%95"><span class="nav-text">多源最短路径——Floyd算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Topological-Sort%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">Topological Sort拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOV%E7%BD%91%E7%BB%9C"><span class="nav-text">AOV网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-text">网络流</span></a></li></ol></li></ol>
    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">萧. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v0.5.2</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/8/17 11:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        

        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fa-solid fa-magnifying-glass-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fa-solid fa-magnifying-glass-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fa-solid fa-left-right"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fa-solid fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fa-solid fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fa-solid fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fa-solid fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>




    
<script src="/js/runtime.js"></script>

    
<script src="/js/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
