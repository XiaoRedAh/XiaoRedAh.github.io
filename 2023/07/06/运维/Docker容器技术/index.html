<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="萧">
    <link rel="canonical" href="http://example.com/2023/07/06/%E8%BF%90%E7%BB%B4/Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            Docker容器技术 |
        
        等想好起什么名字后再来改
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"0.5.2","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">
    
    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                等想好起什么名字后再来改
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        主页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        存档记录
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories"  >
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/link2">LINK2
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/link3">LINK3
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                主页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                存档记录
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/categories"  >
                             
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                快捷链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link2">LINK2</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link3">LINK3</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:2rem; font-weight: bold; margin: 10px 0;">Docker容器技术</h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">萧</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-07-06 17:45:48</span>
        <span class="mobile">2023-07-06 17:45</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p><strong>Docker官网</strong>：<a class="link"   target="_blank" rel="noopener" href="https://www.docker.com/" >https://www.docker.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>入门文档</strong>：<a class="link"   target="_blank" rel="noopener" href="https://www.yuque.com/wukong-zorrm/xwas40" >https://www.yuque.com/wukong-zorrm/xwas40 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>准备</strong>：配置2C2G以上Linux服务器一台，云服务器、虚拟机均可。</p>
<h2 id="虚拟机与容器"><a href="#虚拟机与容器" class="headerlink" title="虚拟机与容器"></a>虚拟机与容器</h2><p><strong>抛出背景</strong></p>
<p>在企业中，服务器是必不可少的一种硬件设施，它其实也是电脑。服务器的配置非常高，服务器级别的CPU动辄12核，甚至服务器还能同时安装多块CPU，能直接堆到好几十核：</p>
<p>家用级CPU一般是AMD的锐龙系列和Intel的酷睿系列（比如i3 i5 i7 i9），而服务器CPU一般是Intel的志强（Xeno）系列，这种CPU的特点就是核心数非常多：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/06/30/cKlhRZ9Sw1Q4uEX.png"
                      alt="image-20220630172135408"
                ></p>
<p>并且服务器CPU相比家用CPU的功耗更大，发热量非常高。</p>
<blockquote>
<p>但是服务器CPU的频率没有家用级CPU高。一般大型游戏要求的是高频率而不是核心数，再加上服务器CPU功耗高，所以并不适合装在家用电脑中。<br>在网上买台式机，看到什么“i9级”CPU千万别买，那些是黑心商家把国外服务器上淘汰下来的服务器CPU（洋垃圾）装成电脑来卖，所以会很便宜，同时核心数又能媲美i9。</p>
</blockquote>
<p>服务器无论是CPU资源还是内存资源都远超家用电脑，只跑一个小小的Java后端，可能顶多就用服务器5%的硬件资源，非常浪费。</p>
<p>为了解决这种资源利用率只有5%-15%的情况，需要想个办法，把这一台服务器分成多个小服务器使用，每个小服务器只分配一部分的资源。但是由于设计上的问题，电脑只能同时运行一个操作系统，那么怎么办呢？</p>
<p><strong>虚拟化技术兴起</strong></p>
<p>此时虚拟化技术就开始兴起了。虚拟化使用<em>软件来模拟硬件</em>并创建虚拟计算机系统。这样一来，企业便可以在单台服务器上运行多个虚拟系统，也就是运行多个操作系统和应用。</p>
<p>比如常用的VMware就是一种民用级虚拟化软件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/06/30/St3hfELQHNdRZmA.png"
                      alt="image-20220630173915254"
                ></p>
<p>可以使用VMware来创建虚拟机，这些虚拟机实际上都是基于当前系统上的VMware软件来运行的。当然VMware也有服务器专用的虚拟化软件。</p>
<p>有了虚拟化之后，服务器就像这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/06/30/BmnC1xETQM4uRHO.png"
                      alt="image-20220630174945749"
                ></p>
<p>相当于通过虚拟机模拟了很多来电脑出来，这样就可以在划分出来的多台虚拟机上分别安装系统和部署应用程序了。并且可以自由分配硬件资源，合理地使用。</p>
<p>一般在企业中，不同的应用程序可能会被分别部署到各个服务器上，隔离开来，此时使用虚拟机就非常适合。</p>
<p>实际上，在腾讯云、阿里云租的云服务器，都是经过虚拟化技术划分出来的虚拟机而已。</p>
<p><strong>容器</strong></p>
<p>容器和虚拟机比较类似，都可以为应用提供封装和隔离，都是软件。</p>
<p>但是容器中的应用运行是<strong>寄托于宿主操作系统</strong>的，实际上依然是在直接使用操作系统的资源（应用程序之间环境依然是隔离的）。</p>
<p>而虚拟机则是完全模拟一台真正的电脑出来，直接就是两台不同的电脑。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/06/30/31GZSh5DE9Vilet.png"
                      alt="image-20220630181037698"
                ></p>
<p>因此容器相比虚拟机就简单多了，并且启动速度也会快很多，开销小了不少。</p>
<p>不过容器火的根本原因还是它的<strong>集装箱思想</strong>。<br>比如写一个论坛、电商这类的Java项目，需要用到数据库、消息队列、缓存等这些中间件。因此如果想要将一个服务部署到服务器上，需要提前准备好各种各样的环境：安装MySQL、Redis、RabbitMQ等应用，配置好环境，再将Java应用程序启动。整个流程下来，光是配置环境就要浪费大量的时间。如果是大型的分布式项目，可能要部署很多台机器，项目上个线就要花几天，显然是不科学的。</p>
<p>而容器<em>可以打包整个环境</em>。比如将MySQL、Redis等中间件以及Java应用程序一起打包为一个镜像，当需要部署服务时，直接下载镜像运行即可，不需要再进行额外的配置。整个镜像中环境是已经配置好的状态，开箱即用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/06/30/NTnU8iSj51CspFw.png"
                      alt="image-20220630182136717"
                ></p>
<p>当下最热门的容器就是Docker了，它的图标上有很多集装箱，每个集装箱代表<strong>环境+应用程序</strong>。<br>Docker可以将任何应用及其依赖打包为一个轻量级，可移植，自包含的容器，<strong>容器可以运行在几乎所有的操作系统上</strong>。</p>
<h2 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h2><p>容器的基石是镜像，有了镜像才能创建对应的容器实例。</p>
<blockquote>
<p>可以将镜像看作一个类，容器就是这个镜像（类）创建出来的实例。一个镜像（类）可以同时创建多个容器（实例）</p>
</blockquote>
<p>在打包项目时，往往需要一个<strong>基本的操作系统环境</strong>，这样才可以在这个操作系统上安装各种依赖软件，比如数据库、缓存等。这种基本的系统镜像，称为<strong>base镜像</strong>。</p>
<p>一般base镜像就是各个Linux操作系统的发行版，比如Ubuntu，CentOS、Kali等等。</p>
<p>拿Centos镜像为例<br>查看大小发现只有272M。不像平时使用的完整系统，base镜像的CentOS<strong>省去了内核</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/dvmqAjKHkucbLFh.png"
                      alt="image-20220701133111829"
                ></p>
<p>Linux操作体系由内核空间和用户空间组成。内核空间是整个Linux系统的核心，Linux启动后首先会加<code>bootfs</code>文件系统，加载完成后会自动卸载掉，之后会加载用户空间的文件系统，这一层是用户可以进行操作的部分</p>
<ul>
<li>bootfs包含了BootLoader和Linux内核，用户不能对这层作任何修改。内核启动之后，bootfs会自动卸载。</li>
<li>rootfs包含了系统上的常见的目录结构，包括<code>/dev</code>、<code> /proc</code>、 <code>/bin</code>等等以及一些基本的文件和命令。</li>
</ul>
<p>base镜像底层会<strong>直接使用宿主主机的内核</strong>（这也是缺点所在，如果软件对内核版本有要求的话，那么此时使用Docker就直接寄了），而rootfs则可以在不同的容器中运行多种不同的版本。<br>所以，base镜像实际上只有CentOS的rootfs，因此很小。其实CentOS镜像里还包含多种基础的软件，而某些操作系统的base镜像甚至精简到不足10M。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r   //查看内核版本</span><br><span class="line">docker run -it centos   //运行base镜像</span><br><span class="line"><span class="built_in">ls</span>    //查看根目录下的文件（发现很多命令都没有，比如clear）</span><br></pre></td></tr></table></figure></div>

<p>几乎所有的镜像都是通过<strong>在base镜像的基础上安装和配置需要的软件</strong>构建出来的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/SDwEqz2b7lA9nJa.png"
                      alt="image-20220701143105247"
                ></p>
<p><strong>分层结构</strong>：每安装一个软件，就在base镜像上叠加一层，这样多个容器都可以将这些不同的层次自由拼装。比如现在好几个容器都需要使用CentOS的base镜像，而上面运行的软件不同，此时分层结构就很有用了，只需要在本地保存一份base镜像，就可以给多个不同的容器拼装使用。</p>
<p>除了这些软件之外，最上层还有一个<strong>可写容器层</strong><br>所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终看到的是一个叠加之后的文件系统。<br>需要修改容器中的文件时，实际上并<strong>不会对镜像直接修改</strong>，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改，不会影响到下面的镜像。这样才能实现镜像给多个容器共享。<br>各个操作如下：</p>
<ul>
<li>文件读取：Docker从最上层往下依次寻找，找到后则打开文件。</li>
<li>文件创建和修改：创建新文件会直接添加到容器层中；修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。</li>
<li>删除文件：从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是<strong>在容器层标记这个删除操作</strong>。</li>
</ul>
<p>也就是说，对整个容器内的文件进行的操作，几乎都是在最上面的容器层进行的，无法干涉到下面镜像层文件，很好地保护了镜像的完整性，实现多个容器共享使用。</p>
<h2 id="容器工作机制简述"><a href="#容器工作机制简述" class="headerlink" title="容器工作机制简述"></a>容器工作机制简述</h2><p>Docker的整体架构：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/06/30/PeaxwNQXkiYSlUv.png"
                      alt="image-20220630184857540"
                ></p>
<p>分为三个部分：</p>
<ul>
<li><strong>Docker 客户端</strong>：docker命令都是在客户端上执行的，操作会发送到服务端上处理。</li>
<li><strong>Docker 服务端</strong>：服务端是启动容器的主体，一般是作为服务在后台运行，支持远程连接。</li>
<li><strong>Registry</strong>：存放Docker镜像的仓库（就像Macen中存放依赖的仓库一样），分为公有和私有仓库。镜像可以从仓库下载到本地存放。</li>
</ul>
<p>举例</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure></div>

<p>这个命令输入之后：</p>
<ol>
<li>Docker客户端将操作发送给服务端，告诉服务端要运行nginx这个镜像。</li>
<li>Docker服务端先看看本地有没有这个镜像，发现没有。</li>
<li>接着，从公共仓库Docker Hub去查找并下载镜像。</li>
<li>下载完成，镜像保存到本地。</li>
<li>Docker服务端加载Nginx镜像，启动容器开始正常运行（容器和其他容器之间，和外部之间，都是隔离的，互不影响）</li>
</ol>
<p>整个流程中，Docker就像是一搜运输船，镜像就像是集装箱。通过运输船（Docker）将世界各地的货物（镜像）送往目的港口。货物到达港口后，Docker并不关心集装箱（镜像）里面是什么，只需要创建容器开箱即用就可以了。</p>
<blockquote>
<p>不过容器依然是寄托于宿主主机的运行的，所以一般在生产环境下，都是通过虚拟化先创建多台主机，然后再到<strong>各个虚拟机中部署Docker</strong>，这样的话，运维效率就大大提升了。</p>
</blockquote>
<h1 id="搭建Docker环境"><a href="#搭建Docker环境" class="headerlink" title="搭建Docker环境"></a>搭建Docker环境</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>容器主要使用linux内核技术，因此Windows下安装docker可能会有遇到各种问题。</p>
<p>通常所说的docker，是指Docker Engine，它是一种容器化技术，用于创建和运行容器。</p>
<p>而在Windows，选择安装Docker Desktop（一个用于操作docker的GUI图形界面化工具），它包含Docker Engine。</p>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>选择docker-ce进行安装即可</p>
<p>官方安装文档：<a class="link"   target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/" >https://docs.docker.com/engine/install/ubuntu/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>① 卸载已安装的旧版本<br>旧版本的Docker使用docker、docker.io以及docker-engine的名称，可能还安装了containerd或runc等等。总之，在安装Docker之前，先卸载所有旧版本：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure></div>

<p>② 安装相关前置依赖</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure></div>

<p>③ 添加官方的GPG key：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line">sudo <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure></div>

<p>④ 配置本地软件仓库，将Docker的库添加到apt资源列表中：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure></div>

<p>④ 安装docker engine</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//安装前更新一次apt</span><br><span class="line">sudo apt-get update</span><br><span class="line">//直接安装Docker最新版本。如果上一步没有配置成功，这里会报错找不到相关软件包。</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure></div>

<p>⑤ 启动docker，运行hello world查看是否成功</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></div>

<p>配置好后，先退出SSH终端，然后重新连接就可以生效了。</p>
<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><p>① 卸载已安装的旧版本<br>旧版本的Docker使用docker、docker.io以及docker-engine的名称，可能还安装了containerd或runc等等。总之，在安装Docker之前，先卸载所有旧版本：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate</span><br></pre></td></tr></table></figure></div>

<p>② 更新系统，并安装依赖</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure></div>

<p>③ 添加 Docker 官方 GPG 密钥：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></div>

<p>④ 安装docker engine</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//先更新，从刚刚配置的 Docker 软件仓库中获取软件包列表</span><br><span class="line">sudo yum update</span><br><span class="line">//直接安装 Docker 最新版本。如果上一步没有配置成功，这里会报错找不到相关软件包。</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure></div>

<p>⑤ 启动docker，运行hello world查看是否成功</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></div>
<h2 id="方便以后使用"><a href="#方便以后使用" class="headerlink" title="方便以后使用"></a>方便以后使用</h2><p><strong>将当前用户添加到docker用户组中</strong>，不然每次使用docker命令都需要sudo执行，很麻烦：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker &lt;用户名&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>配置国内镜像仓库地址</strong><br>新建&#x2F;etc&#x2F;docker&#x2F;daemon.json文件，输入如下内容：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://fsp2sfpr.mirror.aliyuncs.com/&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后重启，配置开机启动</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> containerd</span><br></pre></td></tr></table></figure></div>

<h1 id="最基本的操作"><a href="#最基本的操作" class="headerlink" title="最基本的操作"></a>最基本的操作</h1><h2 id="镜像基本操作"><a href="#镜像基本操作" class="headerlink" title="镜像基本操作"></a>镜像基本操作</h2><p><strong>拉取&#x2F;上传&#x2F;删除&#x2F;查看&#x2F;搜索镜像</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//从远程仓库拉取镜像(版本默认最新)</span><br><span class="line">docker pull 镜像:版本</span><br><span class="line"></span><br><span class="line">//登录远程仓库</span><br><span class="line">docker login -u 用户名</span><br><span class="line"></span><br><span class="line">//将本地镜像上传到远程仓库</span><br><span class="line">docker push 镜像:版本</span><br><span class="line"></span><br><span class="line">//删除镜像</span><br><span class="line">docker rmi 镜像</span><br><span class="line"></span><br><span class="line">//查看本地有哪些镜像</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">//从远程仓库搜索镜像</span><br><span class="line">docker search 镜像</span><br><span class="line"></span><br><span class="line">//查看镜像构建历史记录</span><br><span class="line">docker <span class="built_in">history</span> 镜像</span><br></pre></td></tr></table></figure></div>

<p><strong>运行镜像：自动创建容器并运行</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//运行镜像（创建容器并运行）</span><br><span class="line">docker run 镜像</span><br><span class="line"></span><br><span class="line">//运行镜像，添加`--name`，可以给容器设置指定名称</span><br><span class="line">docker run --name=lbwnb 镜像</span><br><span class="line"></span><br><span class="line">//运行镜像，--<span class="built_in">rm</span>表示容器在停止后自动删除</span><br><span class="line">docker run --<span class="built_in">rm</span> 镜像</span><br><span class="line"></span><br><span class="line">//-p指定宿主机与docker服务器的端口映射，-d表示后台运行</span><br><span class="line">docker run -p 8080:8080 -d 镜像</span><br></pre></td></tr></table></figure></div>

<p><em>注意：有一些镜像仅仅run，不会做任何事，因此直接就关掉了，比如base镜像。因此需要在run的时候给它们些事情做。</em></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//`-i`表示在容器上打开一个标准的输入接口，</span><br><span class="line">//`-t`表示分配一个伪<span class="built_in">tty</span>设备，可以支持终端登录</span><br><span class="line">//-it 表示使用交互模式，可以在控制台里输入、输出</span><br><span class="line">//一般这两个是一起使用，否则base容器启动后就自动停止了。</span><br><span class="line">docker run -it centos</span><br></pre></td></tr></table></figure></div>

<h2 id="容器基本操作"><a href="#容器基本操作" class="headerlink" title="容器基本操作"></a>容器基本操作</h2><p><strong>手动启动&#x2F;终止&#x2F;暂停&#x2F;恢复&#x2F;重启&#x2F;删除容器</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//只想创建容器而不想马上运行，可以使用create命令：</span><br><span class="line">docker create 镜像名</span><br><span class="line"></span><br><span class="line">//手动开启处于停止状态的容器（容器ID比较长，可以只写部分，只要保证能唯一识别到即可）</span><br><span class="line">docker start &lt;容器名称/容器ID&gt;</span><br><span class="line"></span><br><span class="line">//终止正在运行的容器（容器完成善后工作后，才会终止）</span><br><span class="line">docker stop &lt;容器名称/容器ID&gt;</span><br><span class="line"></span><br><span class="line">//立即终止正在运行的容器</span><br><span class="line">docker <span class="built_in">kill</span> &lt;容器名称/容器ID&gt;</span><br><span class="line"></span><br><span class="line">//暂停运行指定的容器</span><br><span class="line">docker pause &lt;容器名称/容器ID&gt;</span><br><span class="line"></span><br><span class="line">//恢复运行指定的容器</span><br><span class="line">docker unpause &lt;容器名称/容器ID&gt;</span><br><span class="line"></span><br><span class="line">//重启容器</span><br><span class="line">docker restart &lt;容器名称/容器ID&gt;</span><br><span class="line"></span><br><span class="line">//容器处于非运行状态时才可以删除：</span><br><span class="line">docker <span class="built_in">rm</span> &lt;容器名称/容器ID&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>后端项目运行时（比如SpringBoot项目），几个常用的控制操作</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//打印日志信息</span><br><span class="line">docker logs 容器名</span><br><span class="line">//持续打印日志信息</span><br><span class="line">docker logs -f 容器名</span><br><span class="line">//容器运行时，进入容器内的终端</span><br><span class="line">docker attach 容器ID/名称</span><br><span class="line">//在容器中创建一个新的终端</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名 bash</span><br><span class="line">//在容器中执行一条命令（会在容器创建一个新的终端来执行命令）</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名 命令</span><br></pre></td></tr></table></figure></div>

<p><em>如果想要退出容器内的终端，需要先按Ctrl+P再按Ctrl+Q来退出。不能直接使用Ctrl+C来终止，这样会直接终止掉Docker中运行的Java程序的</em></p>
<p><strong>查看容器</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查看所有的容器及它们的状态（若无-a，只能看到正在运行的容器）</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/qOblnhr5CJiIBG6.png"
                      alt="image-20220701125951980"
                ></p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><h3 id="使用Dokcerfile-推荐"><a href="#使用Dokcerfile-推荐" class="headerlink" title="使用Dokcerfile(推荐)"></a>使用Dokcerfile(推荐)</h3><p><strong>dockerfile常用参数</strong><br><code>FROM</code> 打包使用的基础镜像<br><code>WORKDIR</code>相当于cd命令，进入工作目录<br><code>COPY</code> 将宿主机的文件复制到容器内<br><code>RUN</code>打包时执行的命令，相当于打包过程中在容器中执行shell脚本。通常用来安装应用程序所需要的依赖、设置权限、初始化配置文件等<br><code>CMD</code>运行镜像时执行的命令<br><code>EXPOSE</code>指定容器在运行时监听的网络端口，它并不会公开端口，仅起到声明的作用，公开端口需要容器运行时使用-p参数指定。</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="comment"># 设置容器启动后的默认运行目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令，安装依赖</span></span><br><span class="line"><span class="comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span></span><br><span class="line"><span class="comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span></span><br><span class="line"><span class="comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span></span><br><span class="line"><span class="comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> python app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></div>

<p><strong>tip</strong></p>
<blockquote>
<p>如果写 Dockerfile不熟练，总是遇到一些运行错误，依赖错误等，可以直接运行一个base镜像，然后进入终端进行配置环境，成功后，再把做过的步骤命令写入Dockerfile 文件中，这样编写调试会快很多。</p>
</blockquote>
<hr>
<p><strong>例子：创建一个带Java环境的Ubuntu系统镜像。</strong></p>
<p>① 新建名为<code>Dockerfile</code>的文件：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure></div>

<p>② 编辑<code>Dockerfile</code>：编写指令来告诉Docker镜像的相关信息</p>
<ul>
<li>首先用<code>FROM</code>选择当前镜像的base镜像（必须以这个指令开始。如果不需要任何基础镜像的话，直接使用<code>scratch</code>表示从零开始构建）</li>
<li>base镜像设定后，使用<code>RUN</code>指令在容器中运行命令安装Java环境（每条指令执行之后，都会生成一个新的镜像层）</li>
</ul>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;基础镜像&gt;</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y openjdk-8-jdk</span></span><br></pre></td></tr></table></figure></div>

<p>③ 只需要完成一次构建即可</p>
<p>执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;镜像名称&gt; &lt;构建目录&gt;</span><br></pre></td></tr></table></figure></div>

<p>构建过程的每一步都非常清晰地列出来了。<br>并且Docker镜像构建有缓存机制，就算现在中途退出了，然后重新进行构建，也会直接将之前已经构建好的每一层镜像，直接拿来用。除非修改了Dockerfile文件重新构建，只要某一层发生变化其上层的构建缓存都会失效，当然包括<code>pull</code>时也会有类似的机制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/g6RFwA5t4EsdvnY.png"
                      alt="image-20220701155443170"
                ></p>
<p>④ 成功安装，会出现在本地</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/95ueUgyaTcrz6Mi.png"
                      alt="image-20220701155847721"
                ></p>
<hr>
<p>使用<code>history</code>命令来查看构建历史：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/GYyHFcjSKJwvWi6.png"
                      alt="image-20220701160128689"
                ></p>
<p>可以看到最上面两层是通过使用apt命令生成的内容，就直接作为当前镜像中的两层镜像，每层镜像都有一个自己的ID，不同的镜像大小也不一样。</p>
<p>如果遇到镜像ID为missing的一般是从Docker Hub中下载的镜像会有这个问题，但是没有太大影响。</p>
<hr>
<h3 id="使用commit-不推荐"><a href="#使用commit-不推荐" class="headerlink" title="使用commit(不推荐)"></a>使用commit(不推荐)</h3><blockquote>
<p>这种方式不会记录镜像构建的过程，使用者并不知道镜像是如何构建出来的，对里面一无所知。并且这样去构建效率很低，如果要同时构建多种操作系统的镜像，就要要一个个去敲。</p>
</blockquote>
<p>① 按需求给容器配置好环境</p>
<p>② 使用<code>commit</code>命令将容器保存为新的镜像</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名称/ID 新的镜像名称</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/sbWLlEoMj2ZPcUV.png"
                      alt="image-20220701152302171"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/3q4juA8vOJew9W6.png"
                      alt="image-20220701152418060"
                ></p>
<hr>
<p>使用<code>history</code>命令来查看构建历史：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/qWUeSF3aKrvwJ8p.png"
                      alt="image-20220701160406891"
                ></p>
<p>发现构建过程根本看不到</p>
<hr>
<h2 id="发布镜像到远程仓库"><a href="#发布镜像到远程仓库" class="headerlink" title="发布镜像到远程仓库"></a>发布镜像到远程仓库</h2><p>远程仓库Docker Hub：<a class="link"   target="_blank" rel="noopener" href="https://hub.docker.com/repositories" >https://hub.docker.com/repositories <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>① 创建仓库，填写信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/3T8xJLgER4cWuQq.png"
                      alt="image-20220701164609666"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/SkCKJmU6Rw2lfzP.png"
                      alt="image-20220701164939268"
                ></p>
<p>创建完成后，就有了一个公共的镜像仓库，可以将本地的镜像上传到这里。</p>
<p>② 使用<code>tag</code>命令来重新打标签，将镜像名称修改得规范一点</p>
<p>这里将版本改成1.0版本，不用默认的latest了<br>修改完成后，会创建一个新的本地镜像，名称自定义的那个</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu-java-file:latest 用户名/仓库名称:版本</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/chAPS2DFW5q7GkE.png"
                      alt="image-20220701165231001"
                ></p>
<p>③ 本地登录</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u 用户名</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/T3YC4pfaLEo85Oz.png"
                      alt="image-20220701165446859"
                ></p>
<p>④ 登录成功后，上传（上传之后的镜像是被压缩过的）</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 镜像</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/CXoBhpZUl79aDRQ.png"
                      alt="image-20220701165744647"
                ></p>
<p>上传完成后，打开仓库，可以看到已经有一个1.0版本了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/3UD9y8frEIX1JY6.png"
                      alt="image-20220701165920060"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/9sVSjcGCo5mTu61.png"
                      alt="image-20220701170053250"
                ></p>
<hr>
<p>测试</p>
<p>先把本地的对应镜像删掉</p>
<p><code>search</code>命令搜索上传的镜像：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nagocoler/ubuntu-java</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/SIUpBOzN5vsiydn.png"
                      alt="image-20220701170253126"
                ></p>
<p>pull命令将其下载下来：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nagocoler/ubuntu-java:1.0</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/uXBk3WPsDM4aZKo.png"
                      alt="image-20220701171148334"
                ></p>
<p>运行试试看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/RJVdstMnxjSYFoW.png"
                      alt="image-20220701171253440"
                ></p>
<hr>
<h2 id="用IDEA构建SpringBoot程序镜像"><a href="#用IDEA构建SpringBoot程序镜像" class="headerlink" title="用IDEA构建SpringBoot程序镜像"></a>用IDEA构建SpringBoot程序镜像</h2><blockquote>
<p>需求：使用Docker快速地将SpringBoot项目部署到安装了Docker的服务器上，我们就可以将其打包为一个Docker镜像。</p>
</blockquote>
<p>① 配置在云服务器&#x2F;虚拟机中的Docker，开启远程客户端访问</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/multi-user.target.wants/docker.service </span><br></pre></td></tr></table></figure></div>

<p>打开后，添加高亮部分：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/OVMDGqiYWU9E7fA.png"
                      alt="image-20220701202846707"
                ></p>
<p>重启Docker服务，如果是云服务器，记得开启2375 TCP连接端口：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker.service </span><br></pre></td></tr></table></figure></div>

<p>② 运行maven的package打包命令，生成项目jar包</p>
<p>③ 项目的resource目录下创建Dockerfile</p>
<ul>
<li>基于ubuntu构建一个带Java环境的系统镜像</li>
<li>COPY命令将jar包拷贝到镜像中。<ul>
<li>第一个参数：要拷贝的本地文件</li>
<li>第二个参数：存放在Docker镜像中的文件位置。这里的<code>app.jar</code>表示保存在默认路径。</li>
</ul>
</li>
<li>CMD命令可以设定容器启动后执行的命令：这里指定启动后运行Java程序</li>
<li>EXPOSE可以指定容器需要暴露的端口，这里暂时不使用，</li>
</ul>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y openjdk-8-jdk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/DockerTest-0.0.1-SNAPSHOT.jar app.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> java -jar app.jar</span></span><br><span class="line"><span class="comment"># EXPOSE 8080</span></span><br></pre></td></tr></table></figure></div>

<p>④ 配置镜像标记（自定义镜像名称）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/edPVg4oyrDiqmk6.png"
                      alt="image-20220701204955570"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/1QrHVB4zC9iFTG7.png"
                      alt="image-20220701205053642"
                ></p>
<p>⑤ IDEA连接Docker服务器进行构建</p>
<p>IDEA自带Docker插件，直接点击左上角的运行按钮，选择<strong>为Dockerfile构建镜像</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/xB5vEw1QHojWZ8p.png"
                      alt="image-20220701203741495"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/FAcME5yxZPD1aoz.png"
                      alt="image-20220701202537650"
                ></p>
<p>在引擎API URL处填写Docker服务器的IP地址：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp://IP:2375</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/bDn3vHFw1XYdusU.png"
                      alt="image-20220701203318098"
                ></p>
<p>⑥ 连接成功后，就可以在Docker服务器上进行构建</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/nPFSa4Wcep31jXG.png"
                      alt="image-20220701203518930"
                ></p>
<p>可以看到，Docker服务器上已经有了刚刚构建好的镜像：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/6JKXLHEz25QGvMk.png"
                      alt="image-20220701205350004"
                ></p>
<hr>
<p><strong>测试</strong></p>
<p>配置完成后，重新构建：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/NgCLJbRQc1lMqna.png"
                      alt="image-20220701210438145"
                ></p>
<p>启动镜像，可以直接在IDEA中启动：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/t2MV3Tu6IcrK8Dl.png"
                      alt="image-20220701210845768"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/JqajY8EdVbGNhiF.png"
                      alt="image-20220701210908997"
                ></p>
<p>启动后可以在右侧看到容器启动的日志信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/jreyMHzcX8LTh3k.png"
                      alt="image-20220701210946261"
                ></p>
<p>但是现在启动，并不能访问到：这是因为容器内部的网络和外部网络是隔离的，如果想要访问容器内的服务器，需要将对应端口绑定到宿主机上，让宿主主机也开启这个端口，这样才能连接到容器内：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d springboot-test:1.0</span><br></pre></td></tr></table></figure></div>

<p>这里<code>-p</code>表示端口绑定，将Docker容器内的端口绑定到宿主机的端口上，这样就可以通过宿主的8080端口访问到容器的8080端口了。<code>-d</code>参数表示后台运行。</p>
<p>当然直接在IDEA中配置也是可以的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/dXQlEBIDzU6YTLG.png"
                      alt="image-20220701211536598"
                ></p>
<p>配置好后，点击重新创建容器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/6G7hbmW81uBsKFc.png"
                      alt="image-20220701211701640"
                ></p>
<p>重新运行后，就可以成功访问到容器中运行的SpringBoot项目了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/7xNrfWcvC58hQ4q.png"
                      alt="image-20220701211753962"
                ></p>
<hr>
<h2 id="用IDEA发布镜像到远程仓库"><a href="#用IDEA发布镜像到远程仓库" class="headerlink" title="用IDEA发布镜像到远程仓库"></a>用IDEA发布镜像到远程仓库</h2><blockquote>
<p>需求：将刚才构建好的镜像推送到Docker Hub</p>
</blockquote>
<p>创建新的公开仓库：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/oTXBtlPV7j3C6a9.png"
                      alt="image-20220701212330425"
                ></p>
<p>直接点击</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/91tKnXDWaeFqcrx.png"
                      alt="image-20220701212458851"
                ></p>
<p>配置Docker Hub相关信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/tMcD2kzNwW9J7d3.png"
                      alt="image-20220701212637581"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/kgTlz3m61ZrHx5s.png"
                      alt="image-20220701212731276"
                ></p>
<p>直接推送即可，等待推送完成。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/H5UfWXC2nKVeray.png"
                      alt="image-20220701212902977"
                ></p>
<p>远程仓库中已经出现了刚刚上传的镜像，IDEA中也可以同步看到：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/01/mgRKV2SWb9YxBGr.png"
                      alt="image-20220701213026214"
                ></p>
<h1 id="容器网络管理"><a href="#容器网络管理" class="headerlink" title="容器网络管理"></a>容器网络管理</h1><h2 id="操作汇总"><a href="#操作汇总" class="headerlink" title="操作汇总"></a>操作汇总</h2><p>一般的，base镜像都只保留最精简的东西，啥软件都没有，需要手动安装网络管理的软件。<br>这里用ubuntu镜像为例，安装网络管理软件后打包成新镜像</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br><span class="line">apt update</span><br><span class="line">apt install net-tools iputils-ping curl</span><br><span class="line">docker commit lucid_sammet ubuntu-net</span><br></pre></td></tr></table></figure></div>

<p><strong>查询主机上的网络类型</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看主机上的网络类型（默认是none，bridge，host）</span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line">//查看当前网络</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure></div>

<p><strong>启动镜像时指定网络类型</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//自带的有none，bridge，host。也可以用自定义的网络</span><br><span class="line">docker run -it --network=网络名 镜像</span><br><span class="line">//不指定，默认使用的是名为bridge的桥接网络</span><br><span class="line">docker run -it 镜像</span><br><span class="line">//将网络指定为另一个容器的网络，实现两个容器网络共享</span><br><span class="line">docker run -it --name=test01 --network=container:test02 ubuntu-net</span><br></pre></td></tr></table></figure></div>

<p><strong>查看网络配置信息</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect 网络名</span><br></pre></td></tr></table></figure></div>

<p><strong>创建自定义网络</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//三种网络驱动：bridge、overlay、macvlan</span><br><span class="line">docker network create --driver 网络驱动 网络名</span><br></pre></td></tr></table></figure></div>

<p><strong>当前容器连接到另一个容器所属的网络下</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect 网络名 容器ID/名称</span><br></pre></td></tr></table></figure></div>


<h2 id="容器网络类型"><a href="#容器网络类型" class="headerlink" title="容器网络类型"></a>容器网络类型</h2><p>Docker在安装后，会在主机上创建三个网络，使用<code>network ls</code>命令来查看：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/7KEumyqriRY2QU5.png"
                      alt="image-20220702161742741"
                ></p>
<p>可以看到默认情况下有<code>bridge</code>、<code>host</code>、<code>none</code>这三种网络类型（有点像虚拟机的网络配置，也是分桥接、共享网络之类的），</p>
<ul>
<li><p><strong>none网络</strong>：这个网络除了有一个本地环回网络之外，就没有其他的网络了。使用none网络的容器是无法连接到互联网的，“真”单机运行，没人能访问进去，绝对的安全，存点密码这些还是不错的。</p>
</li>
<li><p><strong>bridge网络</strong>：容器默认使用的网络类型，即桥接网络。这是应用最广泛的网络类型。宿主机可以ping通容器ip，容器中也能ping通宿主机。<br>容器之间只能通过 IP 地址相互访问，由于容器的ip会随着启动顺序发生变化，因此不推荐使用ip访问。</p>
<p>在宿主主机上查看网络信息，会发现有一个名为docker0的网络设备，这个网络设备是Docker安装时自动创建的虚拟设备。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/jDKSIriXec96uhy.png"
                      alt="image-20220702172102410"
                ></p>
<p>默认创建的容器内部的情况：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu-net</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/5JdimQWMaCx7hy2.png"
                      alt="image-20220702172532004"
                ></p>
<p>可以看到容器的网络接口地址为172.17.0.2，实际上这是Docker创建的虚拟网络。就像容器单独插了一根虚拟的网线，连接到Docker创建的虚拟网络上，而docker0网络实际上作为一个桥接的角色，一头是自己的虚拟子网，另一头是宿主主机的网络。</p>
<p>网络拓扑类似于下面这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/xCKMIBwjq7gWOko.png"
                      alt="image-20220702173005750"
                ></p>
<p>通过添加这样的网桥，就可以对容器的网络进行管理和控制。<br>使用<code>network inspect</code>命令来查看docker0网桥的配置信息：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/86XdZUejEuk1P3i.png"
                      alt="image-20220702173431530"
                ></p>
<p>这里的配置的子网是172.17.0.0，子网掩码是255.255.0.0，网关是172.17.0.1，也就是docker0这个虚拟网络设备。所以上面创建的容器就是这个子网内分配的地址172.17.0.2了。</p>
</li>
<li><p><strong>host网络</strong>：容器连接到此网络后，会共享宿主主机的网络，网络配置也是完全一样的：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=host ubuntu-net</span><br></pre></td></tr></table></figure></div>

<p>网络列表和宿主主机的列表是一样的，连hostname都是和外面一模一样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/cRAQtIxV4D9byCu.png"
                      alt="image-20220702170754656"
                ></p>
<p>只要宿主主机能连接到互联网，容器内部也可以<br>这样直接使用宿主的网络，传输性能基本没有什么折损，而且可以直接开放端口等，不需要进行任何的桥接：</p>
<p>比如安装Nginx之后直接就可以访问了，不需要开放什么端口：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y systemctl nginx</span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure></div>

<p>相比桥接网络就方便得多。【慎用，有安全隐患】</p>
</li>
</ul>
<h2 id="用户自定义网络"><a href="#用户自定义网络" class="headerlink" title="用户自定义网络"></a>用户自定义网络</h2><p>除了以上三种网络，还可以自定义网络，让容器连接到这个网络。</p>
<p>Docker默认提供三种网络驱动：<code>bridge</code>、<code>overlay</code>、<code>macvlan</code>，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样。<br>比如bridge类型的，其实就和前面提到的桥接网络是一样的。</p>
<p><strong>例子</strong></p>
<p>创建一个名称为test的桥接网络</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge <span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/piCtK8kdRALHSIu.png"
                      alt="image-20220702180837819"
                ></p>
<p>可以看到新增了一个网络设备，这个就是负责容器网络的网关，和之前的docker0是一样的：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect <span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/uLwAD4YC3UFXQt7.png"
                      alt="image-20220702181150667"
                ></p>
<p>创建一个使用此网络的新容器<br>成功得到分配的IP地址，是在这个网络内的</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=<span class="built_in">test</span> ubuntu-net</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/Iy2BwDoZsLMO8gJ.png"
                      alt="image-20220702181252137"
                ></p>
<p>再创建一个不同网络的容器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/b14dflKGMunULQI.png"
                      alt="image-20220702181808792"
                ></p>
<p>可以看到不同的网络是相互隔离的，无法进行通信。</p>
<p>可以将此容器连接到另一个容器所属的网络下：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect <span class="built_in">test</span> 容器ID/名称</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/WzvhI63ydfeJStA.png"
                      alt="image-20220702182050204"
                ></p>
<p>这样就连接了一个新的网络：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/lxqrz36sVUjNdI4.png"
                      alt="image-20220702182146049"
                ></p>
<p>可以看到容器中新增了一个网络设备连接到自己定义的网络中，现在这两个容器在同一个网络下，就可以相互ping了：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/WBlC9PheETO64xq.png"
                      alt="image-20220702182310008"
                ></p>
<h2 id="容器间网络"><a href="#容器间网络" class="headerlink" title="容器间网络"></a>容器间网络</h2><p><strong>只要两个容器处于同一个网络下，即可直接通过容器的IP地址在容器间进行通信</strong></p>
<p>创建两个ubuntu容器：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu-net</span><br></pre></td></tr></table></figure></div>

<p>先获取其中一个容器的网络信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/yTEcg4l2kASBnQu.png"
                      alt="image-20220702175353454"
                ></p>
<p>可以直接在另一个容器中ping通这个容器，因为这两个容器都是使用的bridge网络，在同一个子网中。</p>
<p><strong>也可以通过容器名进行通信（只会在自定义的网络下生效，默认网络不生效）</strong></p>
<p>大部分情况下，容器部署之后的IP地址是自动分配的（可以用<code>--ip</code>手动指定，但还是不方便），无法提前得知IP地址，用IP通信的做法不灵活。</p>
<p>这时可以借助Docker提供的DNS服务器。</p>
<p>只需要在容器启动时给个名字，直接访问这个名称，会被解析为对应容器的IP地址。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=test01 --network=<span class="built_in">test</span> ubuntu-net</span><br><span class="line">docker run -it --name=test02 --network=<span class="built_in">test</span> ubuntu-net</span><br></pre></td></tr></table></figure></div>

<p>直接ping对方的名字就可以了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/lKCFY6ec17N4b5y.png"
                      alt="image-20220702192457354"
                ></p>
<p><strong>两个容器共享同一个网络</strong><br>这种情况，两个容器共同使用一个IP地址</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=test01 --network=container:test02 ubuntu-net</span><br></pre></td></tr></table></figure></div>

<p>这里将网络指定为另一个容器的网络，这样两个容器使用的就是同一个网络了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/Wb6jODxFP3r1mE7.png"
                      alt="image-20220702200711351"
                ></p>
<p>可以看到两个容器的IP地址和网卡的Mac地址是完全一样的，此时在容器中访问localhost，既是自己也是别人。</p>
<p>在容器1中，安装Nginx，然后再容器2中访问：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y systemctl nginx</span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/WTn9OMYmLZJXtBz.png"
                      alt="image-20220702201348722"
                ></p>
<p>成功访问到另一个容器中的Nginx服务器。</p>
<h2 id="容器外部网络"><a href="#容器外部网络" class="headerlink" title="容器外部网络"></a>容器外部网络</h2><p>容器如何与外网通信？</p>
<p>在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网。共享模式实际上就是直接使用宿主主机的网络设备连接到互联网。</p>
<p>这里主要来看桥接模式：<strong>NAT+端口映射（这个要自己配）</strong></p>
<p>桥接模式会创建一个单独的虚拟网络，让容器在这个虚拟网络中，然后通过桥接器与外界相连。与外网通信时，数据包从容器内部的网络到达宿主主机，然后再发送到外网。</p>
<p>整个过程的关键是依靠NAT进行IP地址转换，再利用宿主主机的IP地址发送数据包。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/ktEA5O9BrmxXbPz.png"
                      alt="image-20220702232449520"
                ></p>
<p>单纯依靠NAT的话，只能容器主动与外界联系，外界无法主动联系容器。而容器可能会部署一些服务，需要外界来主动连接。</p>
<p>解决方法是，在启动容器时配置端口映射，比如：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure></div>

<p><code>-p</code>参数进行端口映射配置，将容器需要对外提供服务的端口映射到宿主主机的端口上。这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口。规则为<code>宿主端口:容器端口</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/WQzEVTwePNaHYgG.png"
                      alt="image-20220702233420287"
                ></p>
<p>一旦监听到宿主主机的80端口收到了数据包，那么会直接转发给对应容器的对应端口。</p>
<p>配置端口映射之后，才可以从外部正常访问到容器内的服务。</p>
<h1 id="容器存储管理"><a href="#容器存储管理" class="headerlink" title="容器存储管理"></a>容器存储管理</h1><h2 id="操作汇总-1"><a href="#操作汇总-1" class="headerlink" title="操作汇总"></a>操作汇总</h2><p><strong>将宿主机指定目录&#x2F;文件挂载到容器指定位置</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果宿主机没有指定目录路径，Docker会自动创建一个目录，</span><br><span class="line">//并且将容器中对应路径下的内容拷贝到这个自动创建的目录中，</span><br><span class="line">//然后挂载到容器</span><br><span class="line">docker run -it -v 宿主机指定目录路径:挂载路径 镜像名</span><br><span class="line"></span><br><span class="line">//--volumes-from继承一个容器的数据卷</span><br><span class="line">docker run -p 80:80 --volumes-from=data_test -d nginx</span><br></pre></td></tr></table></figure></div>

<p><strong>删除数据卷</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看现存的数据卷</span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line">//删除指定数据卷</span><br><span class="line">docker volume <span class="built_in">rm</span> 数据卷名</span><br></pre></td></tr></table></figure></div>

<h2 id="容器持久化存储"><a href="#容器持久化存储" class="headerlink" title="容器持久化存储"></a>容器持久化存储</h2><p>在容器中创建和修改的文件，实际上是被容器的分层机制保存在最顶层的容器层进行操作的。这个CopyOnWrite特性，是为了保护下面每一层镜像不被修改。</p>
<p>但是这会导致容器在销毁时数据丢失，重新创建新容器，直接回到梦开始的地方。</p>
<p>如果希望对容器内的某些文件进行持久化存储，就要用到<strong>数据卷（Data Volume）</strong></p>
<p><strong>将文件保存到宿主主机上，这样就算容器销毁，文件依然在宿主主机上保留，下次创建容器时，从宿主主机读取对应的文件即可</strong></p>
<p><strong>具体做法是，将宿主主机上的文件直接挂载到容器中，容器直接访问宿主主机上的文件</strong></p>
<hr>
<p><strong>实验</strong></p>
<p>用到的镜像：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br><span class="line">apt update &amp;&amp; apt install -y vim</span><br><span class="line">docker commit</span><br></pre></td></tr></table></figure></div>

<p>用户目录下创建一个新的<code>test</code>目录，在里面创建一个文件，写点内容：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">vim <span class="built_in">test</span>/hello.txt</span><br></pre></td></tr></table></figure></div>

<p>将宿主主机上的目录或文件挂载到容器的某个目录上：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/test:/root/test ubuntu-volume</span><br></pre></td></tr></table></figure></div>

<p><code>-v</code>用于指定文件挂载。这里将刚刚创建好的test目录挂载到容器的&#x2F;root&#x2F;test路径上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/ztEJDC4PTVAyZF2.png"
                      alt="image-20220703105256049"
                ></p>
<p>上图可以看到，直接在容器中就能访问宿主主机上的文件了。</p>
<p><strong>对挂载目录进行编辑，编辑的是宿主主机的数据。</strong><br>比如下面在挂载目录中创建一个test.txt文件</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/test/test.txt  </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/YqUHkJiTG3Q9pAM.png"
                      alt="image-20220703105626105"
                ></p>
<p>在宿主主机的对应目录下，可以直接访问到刚刚创建好的文件。</p>
<p>容器销毁后，挂载的数据依然保留：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/B5M6Wy8AxIoqJtC.png"
                      alt="image-20220703105847329"
                ></p>
<hr>
<p><strong>例子：nginx代理前端项目</strong></p>
<p>直接将前端页面保存到宿主主机上，然后通过挂载的形式让容器中的Nginx访问。<br>就算之后Nginx镜像有升级，需要重新创建，也不会影响到前端页面。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//将前端模板上传到服务器</span><br><span class="line">scp Downloads/moban5676.zip 192.168.10.10:~/</span><br><span class="line">//解压</span><br><span class="line">unzip moban5676.zip</span><br><span class="line">//启动nginx容器，将解压出来的目录挂载到容器中Nginx的默认站点目录`/usr/share/nginx/html/`</span><br><span class="line">docker run -it -v ~/moban5676:/usr/share/nginx/html/ -p 80:80 -d nginx</span><br><span class="line">//重启nginx服务</span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure></div>

<p>将解压出来的目录，挂载到容器中Nginx的默认站点目录<code>/usr/share/nginx/html/</code>（由于挂载后位于顶层，会替代镜像层原有的文件），Nginx直接代理了存放在宿主主机上的前端页面。别忘了把端口映射到宿主主机上。</p>
<p>通过浏览器访问发现代理成功：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/YtgXWizh765qFxr.png"
                      alt="image-20220703111937254"
                ></p>
<hr>
<p><strong>不指定宿主机上的目录进行挂载</strong></p>
<p>使用<code>-v</code>参数时不指定宿主主机上的目录进行挂载的话，Docker会自动创建一个目录，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，然后挂载到容器。这种就是由Docker管理的数据卷（docker managed volume）</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /root/abc ubuntu-volume</span><br></pre></td></tr></table></figure></div>
<p>这里仅仅指定了挂载路径，没有指定宿主主机的对应目录：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/fXCl7IRqKBvYwxj.png"
                      alt="image-20220703112702067"
                ></p>
<p>创建后可以看到<code>root</code>目录下有一个新的<code>abc</code>目录</p>
<p>使用<code>inspect</code>命令查找它在宿主主机的位置</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect bold_banzai </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/zFotAfeBpcRjKWN.png"
                      alt="image-20220703113507320"
                ></p>
<p>可以看到Sorce指向的是<code>/var/lib</code>中的某个目录。<br>进入这个目录来创建一个新的文件（记得先提升权限）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/2bfokiMTmdGZcUE.png"
                      alt="image-20220703114333446"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/yi1hSPC3bAndMXm.png"
                      alt="image-20220703114429831"
                ></p>
<p>和之前一样，也是可以在容器中看到的，容器销毁后，数据依然保留。</p>
<hr>
<p><strong>不挂载目录</strong></p>
<p>为了方便，有时并不需要直接挂载一个目录上去。<br>可以用<code>cp</code>命令在宿主主机和容器间传递一些文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/uw7S5PobAUWBtCI.png"
                      alt="image-20220703115648195"
                ></p>
<h2 id="容器数据共享"><a href="#容器数据共享" class="headerlink" title="容器数据共享"></a>容器数据共享</h2><p><strong>两个容器挂载同一个目录实现数据共享</strong></p>
<p>继续使用<strong>挂载的思路</strong>：在宿主主机创建一个公共的目录，让需要实现共享的容器，都挂载这个公共目录：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/test:/root/test ubuntu-volume</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/soxdKyY4MIXBOin.png"
                      alt="image-20220703141840532"
                ></p>
<p>两个容器挂载宿主主机上的同一块区域，这两个容器都能访问到这里面的数据。</p>
<p>也可以将容器B挂载的目录指定使用容器挂载A的目录<br>这里使用<code>--volumes-from</code>指定另一个容器，这种用于给其他容器提供数据卷的容器，称为<strong>数据卷容器</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/test:/root/test --name=data_test ubuntu-volume</span><br><span class="line">docker run -it --volumes-from data_test ubuntu-volume</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/Uu4CjSZifv1Oyr7.png"
                      alt="image-20220703142849845"
                ></p>
<p>数据卷容器中挂载的内容，在当前容器中也是存在的。就算此时数据卷容器被删除，也不会影响到这边。因为这边相当于是继承了数据卷容器提供的数据卷，本质上还是让两个容器挂载了同样的目录实现数据共享。</p>
<hr>
<p><strong>将数据放在容器中进行共享</strong></p>
<p>通过上面的方式实际上并不方便。某些时候仅仅是希望容器之间共享，而不希望有宿主主机这个角色直接参与到共享之中。<br><strong>可以将数据完全放入到容器中，直接将容器中打包好的数据分享给其他容器</strong>。本质上依然是一个Docker管理的数据卷，虽然还是没有完全脱离主机，但是移植性高得多。</p>
<p>Dockerfile：</p>
<div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line">//复制文件到容器中，并自动解压</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> moban5676.tar.gz /usr/share/nginx/html/</span></span><br><span class="line">//<span class="keyword">VOLUME</span><span class="language-bash">指令和`-v`参数一样，会创建一个挂载点在容器中</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /usr/share/nginx/html/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">tar -zcvf moban5676.tar.gz *</span><br><span class="line"><span class="built_in">mv</span> moban5676.tar.gz ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure></div>

<p>直接构建：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t data .</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/M7jxBUsApKtgzku.png"
                      alt="image-20220703153109650"
                ></p>
<p>现在运行一个容器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/SUg32jlwMcY7Btp.png"
                      alt="image-20220703153343461"
                ></p>
<p>可以看到所有的文件都自动解压出来了（中文文件名称，不过无关紧要）</p>
<p>退出容器，可以看到数据卷列表中新增了这个容器需要使用的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/m6VCIbXyMxt3ilT.png"
                      alt="image-20220703153514730"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/KyLUic5r6oW4HDx.png"
                      alt="image-20220703153542739"
                ></p>
<p>这个位置实际上就是数据存放在当前主机上的位置了，不过是由Docker进行管理而不是自定义的。<br>现在可以创建一个新的容器直接继承了：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --volumes-from=data_test -d nginx</span><br></pre></td></tr></table></figure></div>

<p>访问一下Nginx服务器，可以看到成功代理：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/03/YtgXWizh765qFxr.png"
                      alt="image-20220703111937254"
                ></p>
<p>自此就实现了将数据放在容器中进行共享，不需要刻意去指定宿主主机的挂载点，而是Docker自行管理。这样就算迁移主机依然可以快速部署。</p>
<h1 id="容器资源管理"><a href="#容器资源管理" class="headerlink" title="容器资源管理"></a>容器资源管理</h1><h2 id="物理资源管理"><a href="#物理资源管理" class="headerlink" title="物理资源管理"></a>物理资源管理</h2><p>对于一个容器，有时并不希望它占据所有的系统资源，而是希望只分配一部分资源给容器。</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p><code>-m</code>对容器的物理内存限制，<code>--memory-swap</code>对内存和交换分区总和进行限制。<br>它们默认都是<code>-1</code>，没有任何限制（如果仅指定<code>-m</code>参数，那么交换内存的限制与其保持一致，内存+交换等于<code>-m</code>的两倍大小）默认情况下跟宿主主机一样，都是2G内存。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -m 内存限制 --memory-swap=内存和交换分区总共的内存限制 镜像名称</span><br></pre></td></tr></table></figure></div>

<hr>
<p><strong>实验</strong></p>
<p>现在将容器的内存限制到100M：物理内存50M，交换内存50M</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0</span><br></pre></td></tr></table></figure></div>

<p>发现因为内存不足无法启动</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/MrBWZKIzgxE94Ck.png"
                      alt="image-20220702104653971"
                ></p>
<h3 id="对CPU资源进行限额"><a href="#对CPU资源进行限额" class="headerlink" title="对CPU资源进行限额"></a>对CPU资源进行限额</h3><p>默认情况下，所有容器平等地使用CPU资源。</p>
<ul>
<li><code>-c</code>选项（或全名<code>--cpu-share</code>）调整容器的CPU权重（默认为1024），实现按需分配资源<br>比如说，两个容器的CPU权重为2比1（注意：多个容器时才会生效）。<br>当CPU资源紧张时，会按照此权重来分配资源；如果CPU资源不紧张，依然有机会使用到全部的CPU资源。</li>
<li><code>--cpuset-cpus</code>限制容器在指定的CPU上运行</li>
<li><code>--cpus</code>限制容器使用的CPU资源数</li>
<li>还有更精细的<code>--cpu-period </code>和<code>--cpu-quota</code>，去阅读文档</li>
</ul>
<hr>
<p><strong>实验<code>-c</code>选项</strong></p>
<p>使用一个压力测试工具来进行验证</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -c 1024 --name=cpu1024 -it ubuntu</span><br><span class="line">docker run -c 512 --name=cpu512 -it ubuntu</span><br></pre></td></tr></table></figure></div>

<p>分别进入容器安装<code>stress</code>压力测试工具：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp; apt install -y stress</span><br></pre></td></tr></table></figure></div>

<p>分别在两个容器中启动压力测试工具，产生4个进程不断计算随机数的平方根：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress -c 4</span><br></pre></td></tr></table></figure></div>

<p>进入top查看CPU状态</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/3dHkMWnq1ZxCyKm.png"
                      alt="image-20220702114126128"
                ></p>
<p>可以看到，权重高的容器分配到了更多的CPU资源，而权重低的容器中，只分配到一半的CPU资源。</p>
<hr>
<p><strong>实验<code>--cpuset-cpus</code></strong></p>
<p>比如现在的宿主机是2核的CPU，可以分0和1这两个CPU给Docker使用。限制后，只会使用CPU 1的资源了</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpuset-cpus=1 ubuntu</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/erovkRBi7hSOuAt.png"
                      alt="image-20220702115538699"
                ></p>
<p>可以看到，4个进程只各自使用了25%的CPU，加在一起就是100%，也就是只能占满一个CPU的使用率。</p>
<p>如果要分配多个CPU，则使用逗号隔开：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpuset-cpus=0,1 ubuntu</span><br></pre></td></tr></table></figure></div>

<hr>
<p><strong>实验<code>--cpus</code></strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpus=1 ubuntu</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/pUGCjlsQbEM2Ika.png"
                      alt="image-20220702120329140"
                ></p>
<p>限制为1后，只能使用一个CPU提供的资源</p>
<h3 id="限制磁盘IO读写性能"><a href="#限制磁盘IO读写性能" class="headerlink" title="限制磁盘IO读写性能"></a>限制磁盘IO读写性能</h3><p><strong>通过<code>--device-read/write-bps</code>和<code>--device-read/write-iops</code>参数磁盘读写性能限制</strong></p>
<ul>
<li>bps：每秒读写的数据量。</li>
<li>iops：每秒IO的次数。</li>
</ul>
<hr>
<p><strong>实验</strong></p>
<p>使用<code>dd</code>命令来测试磁盘读写速度：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/tmp/1G bs=4k count=256000 oflag=direct</span><br></pre></td></tr></table></figure></div>

<p>不用等待跑完，中途Ctrl+C结束就行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/1y3O2qbaMsxDFUJ.png"
                      alt="image-20220702121839871"
                ></p>
<p>可以看到当前的读写速度为86.4 MB&#x2F;s。</p>
<p>这里使用BPS作为限制条件：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --device-write-bps=/dev/sda:10MB ubuntu</span><br></pre></td></tr></table></figure></div>

<p>因为容器的文件系统是在<code>/dev/sda</code>上的，所以填<code>/dev/sda:10MB</code>来限制对&#x2F;dev&#x2F;sda的写入速度只有10MB&#x2F;s</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/EczxDAmUCvlwT5u.png"
                      alt="image-20220702122557288"
                ></p>
<p>可以看到现在的速度就只有10MB左右了。</p>
<h2 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h2><h3 id="status-x2F-top命令"><a href="#status-x2F-top命令" class="headerlink" title="status&#x2F;top命令"></a>status&#x2F;top命令</h3><p><code>stats</code>命令可以实时对容器的各项状态进行监控，包括内存使用、内存分配限制、CPU占用、网络I&#x2F;O、磁盘I&#x2F;O等信息</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure></div>

<p><code>top</code>命令查看容器中的进程<br>可以携带一些参数，具体的参数与Linux中<code>ps</code>命令参数一致</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID/名称</span><br></pre></td></tr></table></figure></div>

<h3 id="Portainer可视化"><a href="#Portainer可视化" class="headerlink" title="Portainer可视化"></a>Portainer可视化</h3><p>除了敲命令之外，可以选择部署一个Docker网页管理面板应用进行监控和管理，比较常用的有：Portainer。</p>
<p>Portainer是一个可视化的Docker管理系统，功能十分全面，提供状态显示面板、应用模板快速部署、容器镜像、网络、数据卷的基本操作、事件日志显示、容器控制台操作、登录用户管理和控制等功能。</p>
<p>通过Docker镜像的方式去部署Portainer应用程序。<br>最新版维护的地址为：<a class="link"   target="_blank" rel="noopener" href="https://hub.docker.com/r/portainer/portainer-ce" >https://hub.docker.com/r/portainer/portainer-ce <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>也可以使用非官方的汉化版本：<a class="link"   target="_blank" rel="noopener" href="https://hub.docker.com/r/6053537/portainer-ce%E3%80%82" >https://hub.docker.com/r/6053537/portainer-ce。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>CE为免费的社区版本（这个够了），官方Linux安装教程：<a class="link"   target="_blank" rel="noopener" href="https://docs.portainer.io/start/install/server/docker/linux" >https://docs.portainer.io/start/install/server/docker/linux <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>安装及部署流程：</p>
<p>① 创建一个数据卷供Portainer使用：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create portainer_data</span><br></pre></td></tr></table></figure></div>

<p>② 通过官方命令安装启动</p>
<p>注意这里需要开放两个端口，一个是8000端口，还有一个是9443端口</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></div>

<p>③ 开启成功，可以直接登录后台面板：<a class="link"   target="_blank" rel="noopener" href="https://ip:9443/" >https://IP:9443/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>这里需要HTTPS访问，浏览器可能会提示不安全，无视就行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/mukzgvnWZyrxeaM.png"
                      alt="image-20220702155637366"
                ></p>
<p>④ 按照提示进行注册，默认用户名就是admin</p>
<p>⑤ 注册完成后，就可以正常使用了</p>
<p>点击Get Started进入到管理页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/P1JIKaMCl7guYoz.png"
                      alt="image-20220702160124676"
                ></p>
<p>看到目前有一个本地的Docker服务器正在运行<br>可以点击进入，进行详细地管理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/07/02/OUTrAEmwsNoSG8Y.png"
                      alt="image-20220702160328972"
                ></p>
<h1 id="Docker-Compose容器编排"><a href="#Docker-Compose容器编排" class="headerlink" title="Docker-Compose容器编排"></a>Docker-Compose容器编排</h1><p>在实际工作中，部署一个应用可能需要部署多个容器【比如现在要在一台主机上部署很多种类型的服务，包括数据库、消息队列、SpringBoot应用程序若干，或是想要搭建一个MySQL集群】，一个个部署非常不方便。</p>
<p>使用docker compose可以一键部署和启动多个容器，它使用yaml文件来编排服务。</p>
<p><strong>详细配置看官方文档</strong>：<a class="link"   target="_blank" rel="noopener" href="https://docs.docker.com/get-started/08_using_compose/" >https://docs.docker.com/get-started/08_using_compose/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>使用流程</strong><br>① 先安装插件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-compose-plugin</span><br><span class="line">//检查版本，验证是否安装成功</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure></div>

<p>② 编写docker-compose.yml文件</p>
<p>③ 在docker-compose.yml 文件所在目录，执行<code>docker-compose up</code>就可以跑起来</p>
<p><strong>常见命令</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在后台运行</span><br><span class="line">docker-compose up -d</span><br><span class="line">//查看运行状态</span><br><span class="line">docker-compose ps</span><br><span class="line">//停止运行</span><br><span class="line">docker-compose stop</span><br><span class="line">//重启</span><br><span class="line">docker-compose restart</span><br><span class="line">//重启单个服务</span><br><span class="line">docker-compose restart service-name</span><br><span class="line">//进入容器命令行</span><br><span class="line">docker-compose <span class="built_in">exec</span> service-name sh</span><br><span class="line">//查看容器运行<span class="built_in">log</span></span><br><span class="line">docker-compose logs [service-name]</span><br></pre></td></tr></table></figure></div>

<p><strong>compose文件结构</strong><br>docker-compose.yml通常需要包含以下几个顶级元素：<br><code>version</code> 已弃用，早期版本需要此元素。<br><code>services</code>必要元素，定义一个或多个容器的运行参数。在services中可以通过以下元素定义容器的运行参数</p>
<ul>
<li><code>image</code> 容器 镜像</li>
<li><code>ports</code>端口映射</li>
<li><code>environment</code>环境变量</li>
<li><code>networks</code>容器使用的网络</li>
<li><code>volumes</code>容器挂载的存储卷</li>
<li><code>command</code>容器启动时执行的命令</li>
<li><code>depends_on</code>定义启动顺序<br>复数形式（例如ports,networks,volumes,depends_on）参数需要传入列表</li>
</ul>
<p><code>networks</code>创建自定义网络<br><code>volumes</code> 创建存储卷</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Docker容器技术</li>
        <li>Post author：萧</li>
        <li>Create time：2023-07-06 17:45:48</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/07/06/运维/Docker容器技术/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/07/06/%E8%BF%90%E7%BB%B4/Nginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Nginx基本使用</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/07/02/%E8%BF%90%E7%BB%B4/%E6%9C%80%E5%8E%9F%E5%A7%8B%E7%9A%84%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%B3%95/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">最原始的部署项目方法</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div style="font-size: 1.3rem;margin-top: 0; margin-bottom: 0.8rem; transition-duration: 0.1s;"><i class="fa-solid fa-list"></i> <strong>Contents</strong></div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%90%86%E8%AE%BA"><span class="nav-text">理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%B9%E5%99%A8"><span class="nav-text">虚拟机与容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84"><span class="nav-text">镜像结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E7%AE%80%E8%BF%B0"><span class="nav-text">容器工作机制简述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%AD%E5%BB%BADocker%E7%8E%AF%E5%A2%83"><span class="nav-text">搭建Docker环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows"><span class="nav-text">Windows</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ubuntu"><span class="nav-text">Ubuntu</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CentOS"><span class="nav-text">CentOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E4%BE%BF%E4%BB%A5%E5%90%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">方便以后使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">最基本的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">镜像基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">容器基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-text">构建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Dokcerfile-%E6%8E%A8%E8%8D%90"><span class="nav-text">使用Dokcerfile(推荐)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8commit-%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-text">使用commit(不推荐)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E9%95%9C%E5%83%8F%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-text">发布镜像到远程仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8IDEA%E6%9E%84%E5%BB%BASpringBoot%E7%A8%8B%E5%BA%8F%E9%95%9C%E5%83%8F"><span class="nav-text">用IDEA构建SpringBoot程序镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8IDEA%E5%8F%91%E5%B8%83%E9%95%9C%E5%83%8F%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-text">用IDEA发布镜像到远程仓库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="nav-text">容器网络管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB"><span class="nav-text">操作汇总</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B"><span class="nav-text">容器网络类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="nav-text">用户自定义网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%97%B4%E7%BD%91%E7%BB%9C"><span class="nav-text">容器间网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C"><span class="nav-text">容器外部网络</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">容器存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB-1"><span class="nav-text">操作汇总</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8"><span class="nav-text">容器持久化存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-text">容器数据共享</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-text">容器资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-text">物理资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-text">分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9CPU%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E9%99%90%E9%A2%9D"><span class="nav-text">对CPU资源进行限额</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E7%A3%81%E7%9B%98IO%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD"><span class="nav-text">限制磁盘IO读写性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7"><span class="nav-text">容器监控</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#status-x2F-top%E5%91%BD%E4%BB%A4"><span class="nav-text">status&#x2F;top命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Portainer%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-text">Portainer可视化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Compose%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92"><span class="nav-text">Docker-Compose容器编排</span></a></li></ol>
    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">萧. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v0.5.2</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/8/17 11:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        

        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fa-solid fa-magnifying-glass-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fa-solid fa-magnifying-glass-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fa-solid fa-left-right"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fa-solid fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fa-solid fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fa-solid fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fa-solid fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>




    
<script src="/js/runtime.js"></script>

    
<script src="/js/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
